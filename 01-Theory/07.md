# Teма 7: Процеси и комуникация между тях в операционната система.

Анотация:
- Процеси и комуникационни канали - основни абстракции, предоставени от операционната система.
- Неформално определение и функционални изисквания.
- Комуникация между процеси чрез споделена памет.
- Съревнование за ресурси (race condition).
- Хардуерна защита на ресурс, синхронизация чрез spinlock.
- Синхронизация от високо ниво – семафор.
- Приспиване и събуждане на процеси(block/wakeup).
- Реализация чрез семафори на комуникационна тръба (pipe), съхраняваща n елемента.

## Процес - определение 
Процес е инстанция на програма, която е в момент на изпълнение в дадена машина.
Това  са поредица от команди по време на изпълнение.
Процесът може да инициира подпроцес, който се нарича детински процес (а иницииращия процес се нарича негов родител).  
Детинският процес е частична реплика на родителския процес и споделя някои от неговите ресурси.
Процесите могат да обменят информация или да синхронизират работата си чрез  няколко метода за междупроцесорна комуникация (Inter process communication – IPC). Te могат да комуникират помежду си чрез споделена памет или чрез обменяне на съобщения.
Операционната система може да имплементира и двата метода на комуникация

## Основни комуникационни канали в ОС Linux
В ОС Linux съществуват различни комуникационни канали, които се използват за взаимодействие между процеси:
- FIFO (неименувана тръба):
    - Реализира се с командата `pipe`.
    - Използва се за комуникация между процеси и техни child процеси.
    - Не използва пространството на имената.
- Именувана тръба:
    - Реализира се с командата `mkfifo`.
    - Представлява специален файл, който действа като тръба и може да бъде достъпен от различни процеси.
    - Използва пространството на имената.
- Връзка процес-файл:
    - Инициализира се с командата `open`.
    - Създава канал между процес и файл от файловата система, чрез който се изпълняват входно-изходни операции.
    - Използва пространството на имената, тъй като файлът трябва да бъде локализиран във файловата система.
- Socket:
    - Инициализира се с командата `socket`.
    - Служи за връзка по мрежата между процеси.
    - Използва пространството на имената от сървърната страна, тъй като клиентският процес трябва да може да намери сървърния процес.

Пояснение: Пространството на имената във файловата система е съвкупността от всички дълготрайни обекти (файлове, директории, връзки), които съществуват в системата, организирани чрез уникални имена. То осигурява идентификация и достъп до тези обекти, като гарантира, че всяко име е еднозначно в своя контекст.
Във виртуалната файлова система (VFS) пространството на имената предоставя унифициран начин за достъп до различни файлови системи, абстрахирайки техните вътрешни разлики и осигурявайки единен интерфейс за потребителите и приложенията

## Състояния на процесите
![Process-States-Diagram](/01-Theory/Images/Process-States.png)
- Running
    - процеси, които активно се нуждаят и използват ядро и процесор, който изчислява.
    - това са процеси, които от гледна точка на потребителя имат работа за вършене.
    - те може да се изчакват и редуват, ако не стигат процесорите, но като цяло имат нужда от изчислителна мощ.
    - от гледна точка на потребителя те са една група, но от гледна точка на ядрото те са:
        - Running – изчисляват се в момента;
        - Ready – в момента няма процесор за тях, но при следващия такт те ще получат управление.
- Sleeping
    - пящите процеси от гледна точка на потребителя са работещи програми, които са стигнали до състояние, при което нямат нужда да изчисляват нещо докато не - настъпят интересни за тях събития в системата.
    - те са в комуникация с друг процес или устройство и очакват да им се подадат данни, но очакваните процеси нямат готовност да им подадат (например поради - запушен комуникационен канал или поради бавна работа на другата страна и т.н.).
    - от гледна точка на реализацията може да чакат:
        - I/O – очаква извършване на входно изходни операции;
        - Time – очаква да настъпи времеви момент;
        - Signal – очаква сигнал от друг процес за промяна на състоянието му (на другия процес);
        - Процеса бива приспан, защото страницата, с която иска да работи не е на реалната памет, а е някъде на твърдия диск.
- Stopped
    - спрян процес (не представлява интерес нито за потребителите, нито за операционната система)
- Zombie
    - процес, при който е започнало спирането но не е завършило (пускането и спирането на процес са бавни и многостъпкови събития)

Разликите в състоянията на процесите въздействат само на процесорите. Спящият процес не използва компютърно време (изчислителен ресурс), а пък работещият процес се бори за компютърно време.

Пояснение: Избора кой от очакващите процесор процеси трябва да му се разреши да работи (най-горната пунктирна стрелка) е най-тънката част от управлението на работата на процесите.
Това се решава от специален алгоритъм в ядрото, който в някои системи се нарича диспетчер а в други task scheduler. Това е частта, в която ОС взима решенията.

## Комуникация между процеси чрез споделена памет 
Комуникацията между процеси в многозадачни операционни системи може да бъде реализирана по няколко начина, като един от най-ефективните и често използвани методи е чрез споделена памет. При този подход два или повече процеса получават достъп до определен сегмент от паметта, в който могат да четат или записват данни. Основно изискване за успешна комуникация чрез споделена памет е наличието на обща променлива или структури от данни, които са достъпни за всички участващи процеси.

Отговорността за правилното използване на споделената памет е изцяло на програмиста, тъй като операционната система осигурява механизма за споделяне, но не дефинира логиката за обмен на информация. Това предполага необходимостта от внимателна синхронизация и управление на достъпа до споделените ресурси, за да се избегнат условия на състезание (race conditions), неконсистентност на данните и други проблеми, свързани с конкурентното изпълнение.

Един елементарен пример за комуникация чрез споделена памет може да бъде представен по следния начин: да разгледаме два процеса — P1 и P2, които се изпълняват конкурентно. Процесът P1 генерира резултати от изчисления или събира данни относно използването на дадени ресурси, след което записва тази информация в предварително дефинирана област от споделената памет. Процесът P2, когато се нуждае от същата информация, извършва проверка на съответния запис в споделената памет, извлича необходимите данни и извършва съответните действия въз основа на получената информация.

Този модел на комуникация позволява двупосочен обмен на данни: както извличане на информация, създадена от един процес, така и предоставяне на информация за използване от други процеси. При това се осигурява висока производителност, тъй като обменът на данни се осъществява директно в потребителското пространство на процесите, без да е необходимо преминаване през ядрото на операционната система, както е при методите за комуникация чрез тръби (pipes, FIFOs) или чрез предаване на съобщения (message passing).

Следователно, комуникацията чрез споделена памет предлага значителни предимства по отношение на скоростта и ефективността, но също така изисква стриктна координация между процесите и често използване на механизми за синхронизация като семафори, мютекси или условни променливи.

### Съревнование за ресурси (race condition) 
Race condition (борба или състезание за ресурси) наричаме явление, при което два или повече процеса/нишки се опитват едновременно да получат достъп до споделени ресурси или да ги променят, без да е гарантиран редът на изпълнение. Това води до непредвидими резултати, защото крайните данни или състоянието зависят от реда на изпълнение.

Пример за това е ситуация, в която един процес проверява дадено условие и действа на база неговата стойност, докато друг процес променя същата стойност между „проверката“ и „действието“. За да се избегне това, се използва синхронизация (например чрез заключвания lock), която гарантира, че само един процес има достъп до ресурса в даден момент.
```bash
if (x == 5) { // „провери“
   y = x * 5; // „действай“
}

vs

lock(x); // заключи x
if (x == 5) {
   y = x * 5; // гарантирано изпълнение
}
unlock(x); // отключи x
```

### Инструменти за избягване на Race Condition:
- Критична секция и атомарна обработка на ресурса
    - Атомарна обработка на ресурс представлява операция, която се изпълнява без прекъсване, като единна неделима инструкция, от операционната система - в един единствен такт.
    - Критична секция е част от кода, която работи със споделени ресурси и трябва да бъде изпълнена атомарно (неделимо).
    - Използва се синхронизация като lock/unlock, за да се гарантира, че само една нишка изпълнява тази част от кода в даден момент.
- Инструменти от ниско ниво и хардуерни средства
    - Spinlock
        - инструмент oт ниско ниво, който посредством ключалка (бит, който е 0 за свободна структура и 1 за заета) кара процесите да чакат в цикъл, докато не се освободи ключалката.
        - Подходящ за кратки критични секции, когато те са дълги има вероятност да се предизвика гладуване на чакащите процеси.
    - Атомарни операции
        - Test-and-Set
            -  Тази инструкция се използва, за да се пише в паметта и да се върне старата стойност като атомарна операция. 
        - Compare&swap/Аtomic swap
            - Атомарната инструкция се използва да се постигне синхронизация.
            - Тя сравнява съдържанието на локация в паметта с дадена очаквана стойност и само ако са същите, модифицира съдържанието с новата стойност. 
        - Enable/disable interrupt
            - Това са инструкции, които временно блокират или разрешават прекъсванията на процесора.
            - Използват се за защита на критични секции в код, особено когато се изпълнява работа в ядрото (kernel mode).
            - Когато процесорът е в kernel mode и изпълнява чувствителен код (например промяна на глобални структури или ресурси), прекъсванията могат да бъдат временно деактивирани, за да се предотврати нежелана намеса.
            - След като операцията приключи, прекъсванията се активират отново.
- Инструменти от високо ниво
    - Семафори
        - Абстрактен механизъм за синхронизация
            - Семафорите са инструменти от високо ниво, използвани за управление на достъпа на множество процеси или нишки до общи ресурси.
        - Приспиване и събуждане
            - Ако процесът не може да получи достъп до ресурса (например ресурсът вече е зает), той бива приспан, вместо активно да изчаква (busy-waiting).
        - Очакване на събитие
            - Процесът се поставя в изчакване, докато не настъпи определено събитие – например ресурсът стане свободен.
        - Събуждане
            - Когато събитието настъпи, процесът се събужда и продължава изпълнението си от мястото, където е бил спрян.

## Deadlock
Deadlock се нарича явлението, при което даден процес чака за достъп до ресурс, който никога няма да получи.
За наличие на Deadlock са необходими 4 условия:

Един процес има ексклузивни права върху ресурса, до който в момента има достъп
Процес може да заяви желание за достъп и до други ресурси докато все още държи тези, до които в момента има достъп
Не може насила да се отнеме ресурса от даден процес
Налична е кръгова опашка от два или повече процеса, всеки от които търси ресурс, който се държи от предходния

## Starvation/Гладуване
Явление, при което процес е лишен от даден ресурс и не може да прогресира в работата си.

Пояснение: Това е различно от deadlock, тъй като при deadlock всички процеси са в състояние на изчакване, а тук те са „живи“ (все едно вършат дадена работа), но всъщност не вършат нищо полезно.           

## Хардуерна защита на ресурс, синхронизация чрез spinlock
 - инструмент oт ниско ниво, който посредством ключалка (бит, който е 0 за свободна структура и 1 за заета) кара процесите да чакат в цикъл, докато не се освободи ключалката.
 - Подходящ за кратки критични секции, когато те са дълги има вероятност да се предизвика гладуване на чакащите процеси.
 - предимства:
    - ефикасност в предотвратяването н race condition-и.
    - проста реализация - лесен за имплементиране и използване на хардуерно ниво.
    - Без контекстни превключвания
        - избягва скъпи контекстни превключвания, тъй като процесът остава активен, вместо да се приспи.
        - това го прави подходящ за кратки критични секции.
    - няма събуждане на процеси - подходящ е за среди, където времето за събуждане на процес е критично.
 - недостатъци:
    - процесите, които циклят (busy-wait), не могат да извършват друга полезна работа, докато чакат, което води до загуба на производителност.
    - може да се получи безкраен цикъл, ако процес, който също има нужда от споделения ресурс, вече е заключил spinlock-а.
    - може да се получи зацикляне на процесора, ако възникне прекъсване по време на изпълнение в критичната секция. Затова прекъсванията трябва да се забраняват преди влизане в критичната секция.

## Синхронизация от високо ниво – семафор 
Семафорът е синхронизационен механизъм, който се използва за управление на достъпа на процеси/нишки до споделени ресурси и предотвратяване на race conditions.

Той включва брояч и контейнер (или списък), който съхранява чакащите процеси.
- cnt : int → брояч (показва колко процеса могат да преминат бариерата, за да ползват споделения ресурс). Ако cnt < 0, то | cnt | е броя на приспаните процеси;
- L : list → контейнер/списък, който може да го разглеждаме като множество от приспани процеси.

Основната идея е да се регулира достъпът до критични секции, като се блокират процесите, ако броячът е 0 или по-малък.

Основните методи за работа със семафори са:
- Init
    - инициализация на семафора с начална стойност на брояча, която показва колко процеси могат да имат достъп до критичната секция едновременно.
- Wait
    - когато процес иска достъп до критичната секция, той извиква метода wait.
    - ако броячът е по-голям от 0, процесът преминава през секцията. Ако броячът е 0 или по-малък, процесът се приспива и се поставя в списъка с чакащи.
- Signal
    - когато процес излезе от критичната секция, той извиква метода Signal, който увеличава брояча на семафора и събужда един от чакащите процеси.

### Разлика между слаб и силен семафор
- Силен семафор
    - контейнерът за чакащите процеси е реализиран като опашка FIFO (First In, First Out).
    - това означава, че процесите се обслужват по реда на тяхното постъпване — първият чакащ процес ще бъде първият, който ще получи достъп до ресурса.
- Слаб семафор
    - в този случай, приоритетите на процесите в списъка с чакащи могат да бъдат различни и не се следва стриктен ред на обслужване (например, процесите с по-висок приоритет може да се обслужват първи).

### Приспиване и събуждане на процес (block/wakeup)
Когато процес чака за дадено събитие, той може да бъде приспиван.
Това означава, че процесът ще бъде спрян, докато не настъпи определено събитие (например завършване на входно-изходна операция или достигане на времеви момент).
Приспиването обикновено се извършва чрез системно извикване като block().
Когато събитието настъпи, процесът се събужда чрез механизъм като wakeup(), за да продължи изпълнението си.

Тръбата, която съхранява един пакет информация, се използва като се редуват операциите четене и писане върху нея. Изпращачите на данни пишат в тръбата, а през това време получателите чакат да вземат данните от нея. Тази операция може да се повтаря множество пъти в двете посоки. 

### Реализация чрез семафори на комуникационна тръба (pipe) 

Реализация чрез семафори:
```
Semaphores: free_bytes, ready_bytes 
free_bytes.init(1) 
ready_bytes.init(0)

Producer:                   Consumer: 
    free_bytes.wait()           ready_bytes.wait() 
    { write to buffer }         { read from buffer } 
    ready_bytes.signal()        free_bytes.signal()
```

Тръбата, която може да съхранява n пакета информация, се реализира чрез опашка, в края на която изпращачите поставят данни, а получателите ги взимат от другата страна (началото), за да ги обработят.

Реализация чрез семафори:
```
Semaphores: mutex_read, mutex_write, free_bytes, ready_bytes 

Data structures: Queue 
Free_bytes.init(n) 
Ready_bytes.init(0) 
Mutex_read.init(1) 
Mutex_write.init(1) 
 
Producer:                   Consumer: 
    free_bytes.wait()           ready_bytes.wait()  
    mutex_write.wait()          mutex_read.wait() 
        { add to Queue }            { retrieve from Queue } 
    mutex_write.signal()        mutex_read.signal() 
    ready_bytes.signal()        free_bytes.signal()
```
