# Тема 11: Процедурно програмиране – основни конструкции & Тема 12: Процедурно програмиране – указатели, масиви и рекурсия

# Развитие на тема:
В програмирането съществуват различни парадигми за изграждане на програми. Една от най-ранните и най-широко използвани е процедурната парадигма. Тя служи като основа за разбирането на съвременни подходи и е неизменна част от изучаването на алгоритми и структури от данни.

## Процедурно програмиране
### Oпределение
Процедурното програмиране е парадигма, при която програмата се изгражда от последователно изпълнявани инструкции, организирани във функции (наричани още процедури). Основният подход е линеен (отгоре надолу), като данните и функциите се третират като отделни компоненти. Всяка функция изпълнява конкретна подзадача и може да бъде извиквана многократно.

### Основни характеристики
Основните характеристики на процедурното програмиране са:
- Функции (процедури)
    ```
    <тип> <име_на_функция>(<параметри>) {
        <тяло_на_функцията>
    }
    ```
    - инструкции, които се характеризират със сигнатура и тяло
    - Те могат да бъдат:
        - дефинирани от потребителя;
        - предоставени от стандартни или външни библиотеки.
- Променливи
    ```
    <тип> <име_на_променлива> = <стойност>;
    ```
    - Локални променливи
        - променливи, които са декларирани в основната структура на функцията и са ограничени до локалния обхват.
        - Може да се използват само във функцията, в който са дефинирани;
    - Глобални променливи
        - глобалните променливи се декларират извън функциите и са достъпни за всички функции в програмата.
- Модулност
    - Програмата се разделя на отделни логически части (модули), които комуникират чрез функции.
        - Различни модули изпълняват различни подзадачи, които заедно изграждат решението на една обща, по-сложна задача. Това подобрява четимостта и улеснява поддръжката на кода.
        - След това всяка група системи ще има свои собствени задачи, завършени една след друга, докато всички задачи не бъдат изпълнени.
    ```
    <тип> функция1(...) { ... }
    <тип> функция2(...) { ... }
    int main() {
        // извиквания към функции
    }
    ```
- Предаване на параметри
    - механизъм, използван за предаване на параметри към функции, подпрограми или процедури.
    - Предаването на параметър може да се извърши чрез:
        - предаване по стойност
        ```
        <тип> <име_на_функция>(<тип> параметър) { ... }
        ```
        - предаване чрез указател
        ```
        <тип> <име_на_функция>(<тип>* параметър) { ... }
        ```
        - предаване чрез референция
        ```
        <тип> <име_на_функция>(<тип>& параметър) { ... }
        ```
### Предимства 
- Ясен и последователен поток на управление;
- Повторна употреба на код чрез функции;
    - Кодът може да се използва повторно в различни части на програмата, без да е необходимо да се копира;
- По-добро управление на паметта.
    - Редуциране на използваната памет;
- Преносимост на кода между различни среди.
    - Изходният код е преносим, следователно може да се използва и за насочване към различни процесори.

### Недостатъци 
- Ограничена структурна гъвкавост при големи проекти;
    - По-труден за писане код, особено ако обема нараства, тъй като липсва йерархия;
- Трудности при моделиране на реалния свят;
    - Трудно се свързва с обекти от реалния свят;
- Данните са изложени на цялата програма, което я прави не толкова защитена

## Основни елементи на програмната структура
В процедурното програмиране програмната структура се състои от ясно дефинирани елементи, които изграждат логиката и потока на изпълнение на програмата.
Тези елементи представляват основните градивни блокове, чрез които се съставят алгоритми, реализират се решения и се създават пълноценни програми.

### Инструкция (statement)
Инструкцията е най-елементарната единица за изпълнение в една програма. 
Това е команда, която казва на компютъра да извърши определено действие.
В езика C++ всяка инструкция завършва с точка и запетая `;`.

Някои основни типове инструкции:
- Присвояване: `a = 5;`
- Извикване на функция: `print();`
- Въвеждане/извеждане: `cin >> x; cout << x;`
- Условна инструкция: `if (x > 0) cout << "положително";`

### Израз (expression)
Изразът представлява комбинация от:
- постоянни стойности (константи) - напр. `3.14`, `'A'`, `true`;
- променливи – напр. `a`, `n`, `sum`;
- оператори – напр. `+`, `-`, `*`, `=`, `==` и др.

Изразът винаги има стойност, която се изчислява в момента на изпълнение.
Примери за изрази:
```c++
a + b;
x > y;
count++;
n % 2 == 0;
```
Изразът може да бъде част от инструкция, напр.:
```c++
int z = x + y * 2;
```

### Блок от инструкции (compound statement)
Блокът от инструкции (или съставна инструкция) позволява да се групират няколко отделни инструкции и да се третират като една логическа единица.
Това се постига чрез заграждане на инструкциите с фигурни скоби `{}`.

Блоковете се използват най-често:
- в тялото на условни конструкции (if, else, switch);
- в цикли (for, while);
- във функции – тялото на функцията е блок.
```
{
    <инструкция1>;
    <инструкция2>;
    ...
}
```

### Коментари
Коментарите са части от кода, предназначени за обяснение, пояснение или временно деактивиране на код.
Те не се изпълняват от компилатора.
В езика C++ се използват два вида коментари:
- Едноредови
```c++
// Това е коментар
```
- Многоредови
```c++
/* текст */
```
Значение:
- Подобряват четимостта на кода;
- Улесняват поддръжката;
- Помагат при работа в екип;
- Полезни при временно изключване на части от кода.

### Условни конструкции
Условните конструкции позволяват изпълнението на различни блокове от код в зависимост от стойността на дадено условие (булев израз).
Използват се за разклоняване на логиката.
- if конструкция
    - Изпълнява блок от код само ако условието е вярно.
    ```c++
    if (условие) {
        // инструкции при вярно условие
    }

    // Пример
    if (x > 0) {
        std::cout << "Положително число";
    }
    ```
- if-else конструкция
    - Изпълнява един блок, ако условието е вярно, и друг – ако е невярно.
    ```c++
    if (условие) {
        // инструкции при вярно условие
    } else {
        // инструкции при невярно условие
    }

    // Пример
    if (x % 2 == 0) {
        std:: cout << "Четно число";
    } else {
        std::cout << "Нечетно число";
    }
    ```
- if - else if - else
    - Използва се, когато има повече от две възможности (разклонения).
    ```c++
    if (условие1) {
        // код при условие1
    } else if (условие2) {
        // код при условие2
    } else {
        // код, ако никое от горните не е вярно
    }

    // Пример
    if (x < 0) {
        std::cout << "Отрицателно";
    } else if (x == 0) {
        std::cout << "Нула";
    } else {
        std::cout << "Положително";
    }
    ```
- switch конструкция
    - Използва се, когато трябва да се избере между множество цели стойности на дадена променлива (обикновено цяло число или символ).
    ```c++
    switch (израз) {
    case стойност1:
        // инструкции
        break;
    case стойност2:
        // инструкции
        break;
    ...
    default:
        // инструкции при липса на съвпадение
    }

    // Пример
    int day = 3;
    switch (day) {
        case 1: cout << "Понеделник"; break;
        case 2: cout << "Вторник"; break;
        case 3: cout << "Сряда"; break;
        default: cout << "Невалиден ден";
    }
    ```
- Тернарен оператор (?:)
    - Тернарният оператор е съкратена форма на условна конструкция if-else, използвана за присвояване на стойност или избор между две алтернативи в едно изречение (израз).
    - Нарича се тернарен, защото работи с три операнда.
    ```c++
    условие ? стойност_ако_е_вярно : стойност_ако_е_невярно;
    
    // Пример
    int a = 5, b = 10;
    int max = (a > b) ? a : b;
    ```

### Цикли (повторения)
Циклите се използват за многократно изпълнение на един и същи блок от код, докато дадено условие е вярно.
- for цикъл
    - Подходящ, когато броят на итерациите е известен предварително.
    ```c++
    for (инициализация; условие; стъпка) {
        // инструкции
    }

    // Пример
    for (int i = 0; i < 5; i++) {
        std::cout << i << " ";
    }
    ```
- while цикъл
    - Използва се, когато броят на повторенията не е известен предварително, а зависи от дадено условие.
    ```c++
    while (условие) {
        // инструкции
    }

    // Пример
    int x = 1;
    while (x <= 5) {
        cout << x << " ";
        x++;
    }
    ```
- do...while цикъл
    - Изпълнява кода поне веднъж, дори ако условието не е вярно в началото.
    - Проверява условието след първото изпълнение.
    ```c++
    do {
        // инструкции
    } while (условие);

    // Пример
    int x = 0;
    do {
        cout << x << " ";
        x++;
    } while (x < 3);
    ```

### Оператори за контрол на потока
Тези оператори управляват потока на изпълнение вътре в цикли или функции.
- break
    - Прекъсва изпълнението на най-близкия цикъл или switch конструкция.
    ```c++
    for (int i = 0; i < 10; i++) {
        if (i == 5) break;
        cout << i << " ";
    }
    ```
- continue 
    - Прекъсва текущата итерация и преминава към следващата.
    ```c++
    for (int i = 0; i < 5; i++) {
        if (i == 2) continue;
        cout << i << " ";
    }
    ```
- return
    - Прекъсва изпълнението на функция и връща стойност (или просто излиза от void функция).
    ```c++
    int max(int a, int b) {
        if (a > b) return a;
        else return b;
    }
    ```
    
## Променливи и типове данни
Програмите работят с данни, които се съхраняват в променливи. 
Всяка променлива има име, тип и стойност, като типът определя размера и вида на допустимите стойности, както и операциите, които могат да се извършват с тях.
```c++
<тип> <име> = <стойност>;
```

### Скаларни типове
Скаларни типове в програмирането са прости типове данни, които съдържат само една стойност наведнъж.
Основните скаларни типове в С++ са:
- int - цяло число, поне 16 бита, със знак (положителни и отрицателни стойности).
- long -  цяло число, поне 32 бита, размерът зависи от платформата (обикновено 32 или 64 бита).
- long long - цяло число с гарантиран 64-битов размер.
- unsigned - цели числа без знак (само положителни и нула).
- float - дробно число, 32 битово, с плаваща запетая, с около 7 десетични знака точност.
- double - дробно число, 64 битово, с плаваща запетая, с около 15 десетични знака точност (двойна точност).
- char – единични символи (буква, цифра или специален знак).
- bool – логически тип (true/false).

Деклариране и инициализация:
```c++
int a = 5;
float pi = 3.14;
char ch = 'A';
bool flag = true;

int b = pi; //3, преобразуване със загуба на информация
```

### Обхват и време на живот на променливите
Променливите съществуват в определен обхват (scope) и имат определен времеви живот (lifetime):
- Локални променливи - дефинирани вътре в функции, достъпни само там;
```c++
void func() {
    int local = 5; // валидна само вътре в func
}
```
- Глобални променливи - дефинирани извън функции, достъпни във всички функции;
```c++
int global = 10;

void print() {
    std::cout << global; // достъпна отвсякъде
}
```
- Автоматични променливи (по подразбиране локални);
    - локални променливи, създават се при влизане в блок и се унищожават при излизане.
    - Ключовата дума auto също може да се използва за автоматично определяне на типа:
```c++
auto x = 3.14; // x e от тип double
```
- Статични променливи - запазват стойността си между извиквания на функцията.
```c++
void counter() {
    static int count = 0;
    count++;
    std::cout << count << std::endl;
}
```

### Оператори
Операторите са символи или комбинации от символи, които извършват операции върху една или повече стойности (операнди).
В C++ операторите се делят на няколко групи според предназначението и броя на операндите.
Всеки оператор се характеризира с:
- позиция на оператора спрямо аргументите му;
- приоритет;
- асоциативност.

Видове оператори според броя на операндите
- Унарен - Работи с един операнд
    | Оператор | Описание                   | Пример     | Забележка                              |
    |----------|----------------------------|------------|----------------------------------------|
    | `+`      | Унарно плюс                | `+x`       | Почти неутрален                        |
    | `-`      | Унарно минус               | `-x`       | Инвертира знака на стойността          |
    | `++`     | Инкремент (увеличение с 1) | `++x`, `x++` | Префиксен или постфиксен               |
    | `--`     | Декремент (намаление с 1)  | `--x`, `x--` | Префиксен или постфиксен               |
    | `!`      | Логическо отрицание        | `!flag`    | Връща `true`, ако `flag` е `false`     |
    | `~`      | Побитово отрицание         | `~x`       | Инвертира всички битове                |
    - Пояснение: `++x` увеличава стойността и връща новата стойност, докато `x++` връща старото число, преди да увеличи.
- Бинарен
    - Работи с два операнда	
    - Аритметични оператори 
        | Оператор | Описание              | Пример     | Резултат                     |
        |----------|-----------------------|------------|------------------------------|
        | `+`      | Събиране              | `a + b`    | Сумата на `a` и `b`          |
        | `-`      | Изваждане             | `a - b`    | Разликата между `a` и `b`    |
        | `*`      | Умножение             | `a * b`    | Произведение на `a` и `b`    |
        | `/`      | Деление               | `a / b`    | Частно (цяло или реално)     |
        | `%`      | Остатък от деление    | `a % b`    | Остатък при целочислено деление |
    - Логически оператори
        | Оператор | Описание | Пример             | Резултат                                 |
        |----------|----------|--------------------|------------------------------------------|
        | `&&`     | И        | `a > 0 && b < 5`   | `true`, ако и двете условия са изпълнени |
        | `||`     | ИЛИ      | `x == 1 || y == 2` | `true`, ако поне едно е вярно            |
    - Оператори за сравнение
        | Оператор | Описание            | Пример     |
        |----------|---------------------|------------|
        | `==`     | Равно               | `a == b`   |
        | `!=`     | Различно            | `a != b`   |
        | `<`      | По-малко            | `a < b`    |
        | `>`      | По-голямо           | `a > b`    |
        | `<=`     | По-малко или равно  | `a <= b`   |
        | `>=`     | По-голямо или равно | `a >= b`   |
    - Оператори за присвояване
        | Оператор | Описание                           | Пример        | Еквивалент на         |
        |----------|------------------------------------|---------------|------------------------|
        | `=`      | Присвояване                        | `a = 5`       | Задава стойност        |
        | `+=`     | Прибавяне и присвояване            | `a += 3`      | `a = a + 3`            |
        | `-=`     | Изваждане и присвояване            | `a -= 2`      | `a = a - 2`            |
        | `*=`     | Умножение и присвояване            | `a *= 4`      | `a = a * 4`            |
        | `/=`     | Деление и присвояване              | `a /= 2`      | `a = a / 2`            |
        | `%=`     | Остатък и присвояване              | `a %= 3`      | `a = a % 3`            |
        | `&=`     | Побитово И и присвояване           | `a &= b`      | `a = a & b`            |
        | `|=`     | Побитово ИЛИ и присвояване         | `a |= b`      | `a = a | b`            |
        | `^=`     | Побитово XOR и присвояване         | `a ^= b`      | `a = a ^ b`            |
        | `<<=`    | Побитово изместване вляво и присв. | `a <<= 1`     | `a = a << 1`           |
        | `>>=`    | Побитово изместване вдясно и присв.| `a >>= 1`     | `a = a >> 1`           |
    - Побитови оператори
        | Оператор | Описание                        | Пример       | Действие                                |
        |----------|----------------------------------|--------------|------------------------------------------|
        | `&`      | Побитово И (AND)                | `a & b`      | 1 само ако и двата бита са 1             |
        | `\|`      | Побитово ИЛИ (OR)               | `a \| b`      | 1 ако поне един бит е 1                   |
        | `^`      | Побитово XOR (изключ. ИЛИ)      | `a ^ b`      | 1 ако битовете са различни               |
        | `<<`     | Побитово изместване наляво      | `a << 2`     | Измества битовете на `a` 2 позиции наляво |
        | `>>`     | Побитово изместване надясно     | `a >> 1`     | Измества битовете на `a` 1 позиция надясно |
- Тернарен
    - Работи с три операнда
    - Пример: Тернарен оператор - `условие ? стойност1 : стойност2`

### Указатели

#### Дефиниция и синтаксис
Указател (pointer) е променлива, която съхранява адреса в паметта на друга променлива от определен тип.
Паметта в един компютър се състои от поредица байтове, които могат да бъдат индексирани чрез цели числа (адреси).
Указателят "помни" адреса на дадена променлива.
```c++
<тип> *име;
```
- Указателят е с фиксиран размер според машината.
    - Ако машината е 32-битова, указателя заема 4 байта.
    - Aко машината е 64 битова, указателя заема 8 байта от паметта.
- Извличане на адрес и инициализация на указател
    - Адресът на дадена променлива се извлича с помощта на унарния оператор &, който се прилага към нея.
    - Пример: ако имаме променлива int num = 489;, искаме да вземем нейния адрес с &num.
    - Унарният оператор & може да се прилага само върху lvalue данни — тоест такива, които имат адрес в паметта.
    - Не може да се прилага върху rvalue данни — стойности, които нямат адрес (напр. временни изрази).
    - Инициализация на указател става чрез задаване на адреса на променливата:
```c++
int* ptr = &num;
```
- типът на указателя трябва да съвпада с типа на данната, към която сочи.
```c++
// Важно: типът на указателя трябва да съвпада с типа на променливата, която сочи.
float pi = 3.14;
float* pi_ptr = &pi;     // правилно
int* wrong_ptr = &pi;    // грешка: различни типове
```
- Съществува тип указател, който няма съответстващ тип на данна - nullptr
    - Pointer literal със специална стойност за нулев адрес (адрес 0x00000000).
    - Използва се за по-безопасно и ясно указване на „нулиран“ указател.
    - Ползваме го за стойност по подразбиране на неинициализиран указател.
```c++
int* ptr = nullptr
```
- Операторът `*` се използва за достъп до стойността, намираща се на даден адрес (дереференция).
```c++
int num = 10;
int* ptr = &num;    // ptr сочи към адреса на num
std::cout << *ptr;  // отпечатва 10
std::cout << ptr;   // отпечатва адресът на num
std::cout << &ptr;  // отпечатва адресът на ptr
```
#### Основни операции с указатели
Указателите могат да участват в:
- аритметика
    - При аритметика, стойността на указателя се увеличава/намалява със стойността на sizeof(тип).
    ```c++
    int* p;     // +1 -> +4 байта
    double* q;  // +1 -> +8 байта
    ```
    - Формално, ако `p` e указател от тип `T`, то инкрементирането на `T*` с `i` e еквивалентно на `p + i * sizeof T`, където `sizeof Т` връща броя 
байтове, необходими за съхраняване на данна от тип `Т`
- логически сравнения
    - При прилагането на оператори за сравнение към указатели се сравняват стойностите на адресите, които те съдържат.
    - Два указателя са равни, ако сочат към един и същ адрес (т.е. към една и съща променлива).
```c++
int x = 5, y = 10;
int* px = &x;
int* py = &y;

if (px != py)
    std::cout << "Указателите сочат към различни променливи";
```

### Maсиви
Масивът е структура от данни, в която се съхраняват множество стойности от един и същи тип, разположени последователно в паметта.
Всеки елемент се достъпва чрез индекс, като индексите започват от 0.
```
<тип> <име>[брой_елементи];
```
- Едномерни масиви
    - Деклариране:
    ```c++
    int arr[5] = {1, 2, 3, 4, 5};
    ```
    - Достъп:
    ```c++
    int x = arr[2];  // x = 3
    ```
- Двумерни масиви
    - Двумерният масив е логическа структура от редове и колони, която се представя в паметта като последователен (линеен) блок от данни.
    - Всеки елемент се достъпва чрез два индекса – един за ред и един за колона, но реално се намира на изчислен адрес.
        - Деклариране:
        ```c++
        int matrix[3][4];
        matrix[1][2] = 7; // достъп до елемент на 2-ри ред и 3-та колона

        // Визуализация
        Редове       [0]       [1]       [2]
           ------------------------------
        Колони      [0][0]   [1][0]   [2][0]
                    [0][1]   [1][1]   [2][1]
                    [0][2]   [1][2]   [2][2]
                    [0][3]   [1][3]   [2][3]
        ```
        - Инициализация чрез цикъл:
        ```c++
        for (int i = 0; i < 3; i++)
            for (int j = 0; j < 4; j++)
                matrix[i][j] = i + j;
        ```

#### Масиви като формални параметри
- Едномерни масиви
    - Когато подаваме масив на функция, той не се копира, а се предава по указател.
    - Това означава, че функцията работи директно с оригиналния масив и всички промени в него ще се отразят и извън функцията.
    ```c++
    void printArray(int arr[], int size);
    ```
    - Следните форми са еквивалентни и се интерпретират като int* arr:
    ```c++
    void func(int arr[]);
    void func(int arr[10]);
    void func(int* arr);
    ```
    - Това позволява оптимизация – не се създава локално копие на масива, което би отнело излишна памет и време.
- Многомерни масиви
    - При многомерни масиви също се предава указател, но трябва да се уточнят размерите на всички измерения, с изключение на първото.
    ```c++
    void printMatrix(int arr[][4], int rows);
    ```
    - В този пример не задаваме броя редове (първото измерение), но трябва задължително да уточним броя колони, за да може компилаторът да изчисли коректно адресите на елементите.
    - Важно: Това правило важи и за масиви с повече от две измерения. Размерите след първото винаги трябва да бъдат уточнени.

### Символни низове
- В C++ съществува типът `char`, който представлява един символ.
- Символите се кодират чрез ASCII стойности, всяка от които е цяло число в интервала [0, 255].
- Типът `char` заема 1 байт памет.
- Низ в C++ представлява масив от символи (`char[]`), завършващ със специалния терминиращ символ `'\0'`.
```c++
// Статичен низ чрез класа `string`
string h = "hello";
// Същият низ като масив от символи
char ch[] = {'h', 'e', 'l', 'l', 'o', '\0'};
```

### Динамични масиви
Освен статичните масиви, съществуват и динамично заделени масиви, които се разполагат в различна част от паметта — т.нар. heap.

| Секция                   | Описание                                                                 |
|-----------------------------|------------------------------------------------------------------------------|
| Код на програмата        | Съдържа машинните инструкции, които се изпълняват                           |
| Глобални/статични данни | Памет за глобални и статични променливи                                     |
| Stack (стек)            | Използва се за извиквания на функции, аргументи и локални променливи        |
| Heap (купа)             | Динамично заделяна памет по време на изпълнение      

Динамичната памет в heap-а се заделя чрез оператора new. Той връща указател към първия елемент на заделената памет.
```c++
int* arr = new int[10];
```
- Тази команда заделя 40 байта (10 елемента по 4 байта) в heap.
- arr е указател към първия елемент от този динамичен масив.

Паметта, заделена с new, не се освобождава автоматично. Задължение на програмиста е да я освободи ръчно, когато вече не е необходима, чрез оператора delete.
```c++
delete ptr; // за единична стойност
delete[] arr; // за масив

// След освобождаване на паметта е добра практика указателят да бъде присвоен към nullptr, за да не сочи към освободена (и потенциално опасна) памет.
ptr = nullptr;
arr = nullptr;
```

При динамично заделяне на двумерен масив в heap паметта не можем да използваме new T[10][10], тъй като това води до едно цяло блоково заделяне, което не е гъвкаво за освобождаване. Вместо това заделяме поетапно:
```c++
int** matrix = new int*[10]; // заделяме масив от 10 указателя (редове)

for (int i = 0; i < 10; ++i) {
    matrix[i] = new int[10]; // заделяме по 10 елемента за всеки ред
}
```
Освобождаване на динамичен двумерен масив - Паметта трябва да се освобождава ред по ред, след което се изтрива и основният масив от указатели:
```for (int i = 0; i < 10; ++i) {
    delete[] matrix[i]; // освобождаваме всеки ред
}
delete[] matrix; // освобождаваме масива от указатели
matrix = nullptr; // добра практика
```

Така се избягват memory leaks – ситуации, при които заделена памет не се освобождава и остава неизползваема, което с времето може да доведе до забавяне или срив на програмата. Чрез правилно освобождаване гарантираме, че всички ресурси са върнати обратно на системата.

## Функции
Функциите са основни програмни единици, които позволяват групиране на код за многократно използване. 
Когато даден код се използва на повече от едно място, той се оформя като функция, която може да бъде извиквана многократно.
Това подобрява четимостта и поддръжката на програмата, като намалява излишъка от повтарящ се код.

### Основни характеристики на функцията
- Сигнатура на функцията
    - Уникален идентификатор на функцията, който включва:
        - името на функцията;
        - броя и типовете на формалните параметри;
        - типа на връщаната стойност.
    - Служи за различаване на функции с еднакво име (претоварване на функции).
- Тип на връщаната стойност
    - Определя какъв тип данни функцията връща при завършване на изпълнението.
    - Ако не връща стойност, типът е void.
- Формални параметри (аргументи)
    - Входни данни, които функцията приема при извикване.
    - Предават се:
        - по стойност – копие на аргумента;
        - по референция – достъп до оригинала;
        - със стойности по подразбиране – използват се, ако не са подадени при извикване.
- Тяло на функцията
    - Състои се от последователност от инструкции, които се изпълняват при извикване.
    - Може да съдържа локални променливи, управляващи конструкции и изрази за връщане на стойност (return).

### Структура на функция
```c++
[<модификатор>] <тип_на_връщане> <име>(<формални_параметри>) {
    // тяло на функцията
}
```
- Модификатори
    - extern
        - модификаторът по подразбиране и може да се пропуска
        - указваме на компилатора, че функцията е декларирана някъде на друго място в кода и за това липсва тяло
    - inline
        - подсказва на компилатора да вмъкне кода на функцията на мястото на извикването за по-бързо изпълнение, където е възможно.
        - може да подобри производителността на кода.
- Тип на функцията
    - описва типа на върнатата стойност, например int, float, void.
- Име
    - служи за идентификация и извикване.
- Формални параметри
    - списък с аргументи, които функцията приема. Могат да имат стойности по подразбиране, които се използват, ако при извикването не се подадат конкретни стойности.

Примери за функции:
```c++
// Дефиниране на функция без аргументи и без да връща стойност.
void print() {
    std::cout << "print text\n";
}

print(); // извикване на функция

// Функция с аргументи по подразбиране:
int sum(int x, int y, int z = 1, int w = 2) {
 return x + y + z + w;
}

// Функция, приемаща параметър по референция (псевдоним)
// Функцията работи с оригиналната променлива
void increment(int &x) {
    ++x;
}
```

### Анонимна фунцкия/Ламбда функция
Функциите може и да са анонимни без име или наричани още ламбда функции.
Обща дефиниция на ламбда функция:
```
[<прихващащ клас>] (<формални параметри>) {
 <тяло>
}
```
Прихващащият клас може да е [&] или [=].
- [&] означава, че променливите са прихванати по референция
- [=] означава, че променливите са прихванати по стойност.
- По подразбиране прихващащият клас е [=].
Пример: Сортиране на масив с анонимна функция функция
```c++
int arr[ ] = {3, 1, 2};
std::sort(begin(arr), end(arr), [&]( int a,  int b) { return a < b; });
```

### Предимства на функциите
- Повторно използване на код;
- Подобрява четимостта и структурата;
- Улеснява поддръжката и тестването.

## Рекурсивни функции 
Рекурсията е функция в програмирането, при който функция извиква сама себе си в рамките на собствената си дефиниция. Тя се използва за решаване на задачи чрез разделяне на проблема на по-малки, подобни подпроблеми.
В теоретичния курс Сложност и изчислимост се изучава важна теорема, според която всяка рекурсивна функция може да бъде преобразувана в еквивалентна итеративна форма. Това доказва, че рекурсията не е необходима от гледна точка на изчислимостта, но е изключително удобна за описание на задачи с естествена рекурсивна структура – напр. обхождане на дървета, изчисляване на факториел, Фибоначи числа и др.

### Видове рекурсия
Рекурсията може да се раздели на няколко вида:
- пряка
    - Функцията извиква директно самата себе си.
    ```c++
    void func() {
        func(); // директно извикване
    }
    ```
- непряка (chain recursion)
    - Една функция извиква друга, която в последствие извиква първата – образува се цикъл от извиквания.
    ```c++
    void A() {
        B();
    }
    void B() {
        A();
    }
    ```
- разклонена
    - Функцията извиква себе си повече от веднъж в хода на своето изпълнение.
    ```c++
    void func(int n) {
        if (n > 0) {
            func(n - 1);
            func(n - 2);
        }
    }
    ```

### Етапи и характеристики на рекурсията
Етапи при изпълнение на рекурсията:
- Разгъване (unwinding/expansion)
    - етапът, в който функцията извиква себе си многократно, създавайки нови стекови рамки.
    - решението на проблема се разделя на по-малки подпроблеми.
- Свиване (rewinding/collapse)
    - етапът, в който започва връщането на стойности от най-дълбокото извикване обратно към изходното.
    - резултатите от подпроблемите се обединяват за получаване на крайния резултат.

### Характеристики и условия на рекурсивните функции:
Дълбочина на рекурсията (характеристика):
- максималният брой вложени (рекурсивни) извиквания на функцията преди достигане на дъното.
Дъно на рекурсията (условие за прекратяване):
- базов случай, при който рекурсивната функция не извиква сама себе си и по този начин започва етапът на свиване.
- Задължителен за всяка коректно дефинирана рекурсивна функция, за да се избегне безкрайна рекурсия.

### Практически съображения
Въпреки че рекурсията позволява елегантно и кратко описание на алгоритми с повтаряща се структура, в реални проекти тя се използва пестеливо поради следните причини:
- Ниска четимост и трудна поддръжка
    - за по-сложни рекурсивни алгоритми е по-трудно да бъдат разбрани и модифицирани от други програмисти.
- Потенциал за грешки
     лесно могат да се пропуснат гранични случаи или базовият случай, което води до безкрайна рекурсия и срив.
- Ограничения в ресурсите
    - всяко рекурсивно извикване използва стекова памет, която е ограничена.
    - Дълбоката рекурсия може да доведе до stack overflow.
Затова в производствен код често се предпочита итеративен подход, дори и когато рекурсивният изглежда по-интуитивен.