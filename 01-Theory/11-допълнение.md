11. (консултация Димитриев)

1. Процедурно програмиране - програмна парадигма. 
Директни инструкции на устройството как да реши задача/проблем.
 
Структурно програмира - частен случай на Процедурно програмиране.
Основната разлика е липсата на оператор goto.
 
2.
2.1 Условни оператори
 
 if(<условие 1>) 
 {
 
 }
 [else if(<условие 2> )  {...} ] 
 …
 [else if(<условие n> )  {...} ] *
 [else {...} ]
 
Какво да бъде изпълнено за да се влезе в тялото на * ?
 
!Условие1 &&  !Условие2 … !Условиеn-1 == false
 Условие n = true
 
switch 
 
switch(<целочислена променлива>)
{
  [case val1: ... break;]
   …
  [case valn: ... break;]
  [default: … break;]
}
 Влиза се в съответен случай, ако подадената има променлива има съотвената стойност. Изпълнението е от оператор : до срещането на ключовата дума break. 
 
 
 Тернарен оператор
 
 <условие> ? <израз 1> : <израз 2>  - Ако условието е истина, се връща израз 1. Ако условието е лъжа, се връща израз 2. 
 
 
2.2 Оператори за цикъл.
 
  while(<условие>)
   {
 
   } //отиваме отново на условието
 Ако условието е истина, се влиза в тялото на цикъла
 
 do {
 
 } while(условие); 
 
  Влиза в тялото поне веднъж, независимо от условието!
 
  Цикъл for 
 
  for(int I = 0; I < 10; i++)
 {
 }
 
  4 компонента:
 1 - Инициализация - Изпълнява се само веднъж!! 
   Създава променлива, видима само в контекста на цикъла!!!
 2 - Проверка - Ако е истина -> се изпълнява тялото. Ако е лъжа - излиза от цикъла
 3 - Актуаизация - Ползва се за обновяване на стойността на променливата, декларирана в инициализацията. Изпълнява след тялото !!! 
 4 - Тяло 
 
  1 2 4 3 2 4 3 2 4 2 … 2 -> false   
 
  Оператор break - прекратява изпълнението на цикъла и излизаме от цикъла 
  Operator continue -  спира текущата итерация на цикъла, но не излизаме от цикъла! 
 
 
3. Променливи.
    <тип> <име> [ = <стойност> ].
  Ако не дадем начална стойност на променливата, не можем да превдидим стойността в нея. 
Локални променлива -  декларирана в тялото на функция!  
 Жизнения цикъл: От нейното деклариране до края на най-вътрешния scope/блок, в който е дефинирана.
 
 {
   {
     int a;
   }
 }
 
 
Глобална променлива - не е декларирана в тялото на функция. 
Видима от всички функции!  Стоят на различно място в паметта от локалните променливи!
 
Оператор за присвояване (assignment operator): 
 
Параметри: 
<променлива>(lvalue) = <променлива/стойност>(lvalue/rvalue)
 
Връща: Променливата от лявата страна! 
 
Оператор = е дясно-асоциативен.
 
 a = b = c = d = e   е еквивалентно на  a = (b = (c = (d = e)))
 
4. Функции и процедури.
Функции - "именована група от инструкции"
 
 <тип на връщане> <име> ([<тип> <име>] ... [<тип> <име>])
 
Предаване на параметри: 
 Като подавате променлива, може да я подадете по копие (стойност) : 
 
  void f(int a) -   f(x);   - а става копие на x. Всички промени по а не се отразяват върху x 
                    f(3); OK!! 
 
  По референция (по име):
 
 void f(int& a)    f(x);  - а e друго име за променлиавата x. 
    f(3) - не е позволено!!!!! f(<променлива>) 
 
  Типове и проверка за съответствие на тип
 Типове - примитивни и съставни.
 Проверка - Компилаторът проверява дали типовете на аргументите съвпада с типовете на параметрите.
 
5. Символни низове - Масив от символи. Има дефиниран символ за край (sentinel), който е '\0'.
 
  char text[] = "Hello" 
  В паметта:
  [H] [e] [l] [l] [o] [\0] 
 
Основни операции със символни низове: 
 int strcmp(const char* lhs, const char* rhs)  - lhs < rhs   0 lhs == rhs   + lhs > rhs
 
 size_t strlen(const char*) - намира дължината на низа
 
 strcat / strcpy / strstr.
