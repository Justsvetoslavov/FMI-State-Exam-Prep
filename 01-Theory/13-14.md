# Тема 13: Обектно-ориентирано програмиране. Основни принципи. Класове и обекти. Наследяване и капсулация & Teма 14:  Обектно-ориентирано програмиране. Подтипов и параметричен полиморфизъм. Множествено наследяване

## Обектно-ориентирано програмиране

Обектно-ориентираното програмиране (ООП) е програмна парадигма, при която една програмна система се моделира като набор от обекти, които взаимодействат помежду си. За разлика от процедурния подход, при който програмата представлява последователен списък от инструкции, тук обектите са основните носители на логика и данни. Всеки обект е способен да получава съобщения, да обработва информация и да комуникира с други обекти.

Обектно-ориентираният подход позволява обединяването на данни и свързани с тях операции в структури, наречени класове, от които се създават обекти. Това води до по-добра организация на кода, повторна употреба, модулност и разширяемост, като същевременно улеснява четимостта и поддръжката на програмата.

## Kласове и обекти

### Клас(class)
В обектно-ориентираното програмиране класът представлява шаблон (или абстракция), по който се създават конкретни инстанции, наречени обекти.
Класът дефинира:
- член-данни (data members)
    - обикновено са асоциирани с всеки отделен обект на класa - описват състоянието на обекта;
    - изключение правят статичните членове (static members), които се споделят между всички обекти.
- член-функции (методи, member functions)
    - описват поведението на обекта.
    - работят с член-данните на класа.
    - извикват се с обект на класа
    - компилаторът преобразува всяка член-функция на дадена структура в обикновена функция с уникално име и един допълнителен параметър - константен указател към обекта.
    ```c++
    bool Point::isInFirstQuadrant() {
	    return x >= 0 && y >= 0;
    }

    // се превежда в:
    bool Point::isInFirstQuadrant(Point* const this) {     
	    //remember since this is a pointer (const) to Point we use the -> operator instead, which is equivalent to (*this).member;
	    return this->x >= 0 && this->y >= 0;
    }

    //Като забележете, че this е const указател към Point, т.е. не можем да меним this, но можем да променяме обекта, който е сочен от него (четем декларациите на указателите отдясно наляво). и съответно
    pt.isInFirstQuadrant();
    // се превежда в:
    Point::isInFirstQuadrant(&pt);
    ```
- Константни член-функции:
    - Не променят член-данните на структурата.
    - Оказва се чрез записването на ключовата дума const в декларацията и в края на заглавието(суфикс) в дефиницията им
    - Могат да се извикват от константни обекти.
    ```c++
    struct obj {
        void inspect() const;   //This member-function promises not to change *this
        void mutate();          //This member-function might change *this
    };

    void Test(obj& changeable, const obj& unchangeable) {
        changeable.inspect();   // Okay: doesn't change a changeable object
        changeable.mutate();    // Okay: changes a changeable object
        
        unchangeable.inspect(); // Okay: doesn't change an unchangeable object
        unchangeable.mutate();  // ERROR: attempt to change unchangeable object
    }
    ```
    - const индикира, че this е указател към const.
    - Член-функции, които използват const по този начин не могат да променят обекта, върху който са извикани!

Класът сам по себе си не заделя памет, тъй като представлява само описание на структурата и поведението на обектите. Памет се заделя едва при създаване на конкретни инстанции (обекти) от този клас. По този начин една програма може многократно да използва еднотипна дефиниция за създаване на множество обекти с еднаква структура, но с различни състояния.

Класовете в C++ се дефинират чрез ключовата дума class, последвана от името на класа и тяло, оградено с `{}` и завършващо със `;`. В тялото на класа се дефинират член-данни и член-функции, разделени чрез модификатори за достъп:
- private: достъпът е ограничен само до методите на същия клас;
- protected: достъпът е разрешен и за производните класове;
- public: достъпът е разрешен за всички.
По подразбиране, ако не е указано друго, членовете на клас са private. При структурите (struct) – по подразбиране са public.

#### Пример - Шаблонен клас
```c++
template<typename K, typename V>
class Pair {
private:
    K key;
    V value;

public:
    Pair() {
        key = K();
        value = V();
    }

    void setKey(K key) { this->key = key; }
    void setValue(V value) { this->value = value; }
    K getKey() { return key; }
    V getValue() { return value; }
};
```
Горният пример показва шаблонен клас, който представя двойка от ключ и стойност. Използването на шаблони позволява генерирането на класове за различни типове по време на компилация.
Уточнение: Препоръчва се член-данните да се подреждат по нарастващ размер в байтове, за да се постигне оптимално подравняване в паметта.

#### Област на класа (област на видимост)
Класовете могат да се дефинират в различни области:
- Глобално (на ниво пространство от имена)
    - класът е достъпен навсякъде в обхвата на програмата след мястото на дефиниция.
- Локално (във функция или в тяло на клас)
    - класът е достъпен само в рамките на тази функция или клас.

Ако клас е дефиниран вътре във функция, всички негови методи трябва да са inline, тъй като C++ не позволява дефиниция на функции вътре във функции (nested functions).

### Обекти
Обект е конкретна инстанция на даден клас. Всеки обект притежава собствено копие на член-данните, а методите се споделят между всички обекти, тъй като са дефинирани веднъж в паметта.

Създаване на обект в C++:
```c++
Pair<int, std::string> p;
```
Тук `Pair` е клас, `p` е обект, който ще притежава своя двойка от `int` и `std::string`.

При създаване на обекти се заделя памет, инициализираща се чрез конструктори. Конструкторите са специални методи, извиквани автоматично при създаване на обект. Всеки обект има собствен контекст, до който методите му имат достъп чрез указателя this. Той сочи към текущия обект и се използва за разграничаване между член-данни и параметри на методите.

### Аксесори и мутатори (Getters и Setters)
Аксесорите (get функции) и мутатори (set функции) са публични методи, чрез които се осигурява контролиран достъп до частните (private) член-данни на класа. Това е част от принципа на капсулацията, който ограничава директната външна манипулация на вътрешното състояние на обекта.
```c++
class Person {
private:
    std::string name;
    int age;

public:
    void setName(const std::string& n) { name = n; }
    std::string getName() const { return name; }

    void setAge(int a) { age = a; }
    int getAge() const { return age; }
};
```
Този подход позволява валидиране на стойности и поддръжка на инварианти (например: възрастта да не е отрицателна).

### Композиция и агрегация
Композицията и агрегацията са начини за моделиране на отношения между класове, при които един обект „съдържа“ друг.

### Композиция (Composition)
Композицията представлява „силна“ връзка между обектите: ако обект A съдържа обект B чрез композиция, то B не може да съществува независимо от A.
```c++
class Engine {
    // ...
};

class Car {
private:
    Engine engine; // композиция
};
// Тук engine е част от Car, създава се и се унищожава заедно с него.
```

### Агрегация (Aggregation)
Агрегацията е „по-слаба“ връзка, при която обектът B може да съществува независимо от обекта A. Обикновено се реализира чрез указатели или референции.
```c++
class Engine {
    // ...
};

class Car {
private:
    Engine* engine; // агрегация
public:
    Car(Engine* e) : engine(e) {}
};
// Тук Car използва Engine, но не го притежава — двигателят може да се използва и от други обекти.
```

## Специални функции – Rule of Five

### Конструктор
Конструкторът е специална член-функция, която се извиква автоматично при създаване на обект. Името ѝ съвпада с това на класа, няма тип на връщане и може да има параметри.
```c++
class A {
public:
    A(); // конструктор по подразбиране
    A(int x); // параметризиран конструктор
};
```

#### Видове конструктори
- По подразбиране (Default Constructor)
    - автоматично се генерира, ако не е дефиниран друг
    - Ако обект се създава без аргументи, той се извиква.
    ```c++
    A a; // default constructor
    ```
- Параметризиран (Parameterized Constructor)
    - приема параметри и се дефинира от програмиста.
    - Ако се дефинира поне един такъв, компилаторът не създава конструктор по подразбиране.
    ```c++
    A(int x) : val(x) {}
    ```
- Копиращ (Copy Constructor)
    - създава нов обект като копие на съществуващ.
    - Прилага се при предаване по стойност, връщане по стойност и инициализация чрез =.
    ```
    A(const A& other);
    ```
- Преместващ (Move Constructor)
    - приема rvalue reference (A&&) и прехвърля ресурси от подадения обект.
    ```c++
    A(A&& other) noexcept;
    ```

Допълнение: Конструкторите могат да инициализират член-данни още преди изпълнение на тялото (Инициализиращ списък)
```c++
A(int x) : val(x), name("default") {}
```

### Деструктор
Извиква се автоматично при унищожаване на обекта – при излизане от scope или при delete.
```c++
~A(); // деструктор
```
Използва се за освобождаване на ресурси (напр. delete[] arr;).
Ако не е дефиниран, компилаторът създава дефолтен деструктор, който не освобождава динамична памет.
```c++
{
    Test t; // Constructor
    {
        Test t2; // Constructor
    } // Destructor (t2)
} // Destructor (t)
```

### Copy assignment operator
- Оператор= (Copy assignment operator)
    - функция/оператор, който приема обект от същия клас и променя данните на съществуващ обект от същия клас (обектът от който извикваме функцията).
```c++
Test(const Test& other); // копиращ конструктор
Test& operator=(const Test& other); // оператор =
```

При липсата на дефиниран/и копиращ конструктор и/или оператор=, компилаторът автоматично създава такива по подразбиране.

Забележка: Копиращият конструктор създава нов обект, а оператор= модифицира вече съществуващ такъв!
```c++
Test t1;
Test t2(t1);  // Copy constructor
t2 = t1;      // Copy assignment
Test t3 = t1; // Copy constructor
```

### Преместване (Move семантика)
Move семантиката позволява трансфер на ресурси от временни (rvalue) обекти, вместо тяхното копиране.
Това осигурява значително подобрение в производителността при работа с ресурсоемки обекти.
```c++
Test(Test&& other) noexcept; // Моve constructor
Test& operator=(Test&& other) noexcept; // Move assignment operator
```
Move конструкторът и операторът за преместване приемат неконстантна rvalue референция към същия тип.
Основната идея е да „откраднем“ ресурсите на other, оставяйки го в безопасно за унищожаване състояние.

#### Пример за move конструктор:
```c++
Student::Student(Student&& other) noexcept : name(other.name), age(other.age) {
	other.name = nullptr; // Оставяме обекта в неопасно за унищожаване състояние
}
```
Така `name` поема указателя от `other.name`, без да се заделя нова динамична памет.
След това присвояваме `nullptr` на `other.name`, за да предотвратим двойно освобождаване на паметта при унищожаване.

#### Пример оператор за присвояване:
```c++
Person& operator=(Person&& other) noexcept {
    if (this != &other) {        // Проверка за самоприсвояване
        free();                  // Освобождаваме текущите ресурси

        name = other.name;       // Прехвърляме указателя към динамичната памет
        age = other.age;         // Копираме стойността на примитивния тип

        other.name = nullptr;    // Оставяме other в безопасно за унищожаване състояние
    }
    return *this;                // Връщаме текущия обект (*this) по референция
}
```
Тук се демонстрира типичният шаблон за оператор за преместване:
- Първо се освобождават старите ресурси на обекта.
- След това се „открадват“ ресурсите на временния обект other.
- Накрая other се поставя в неутрално състояние, за да не се получи двойно освобождаване на паметта в деструктора.

### Синтезирани move операции
Компилаторът може автоматично да генерира move конструктор и move оператор за присвояване, при следните условия:
- Класът няма дефинирани: copy конструктор, copy оператор или деструктор.
- Всички член-данни на класа поддържат преместване (т.е. имат move конструктор/оператор).
Ако някой от горните copy контрол методи е дефиниран ръчно, move операциите не се синтезират автоматично.

Поведение при липса на дефинирани move операции
- Ако няма налични move операции, компилаторът прибягва до copy семантика, дори при временни обекти - ...което е по-неефективно и именно затова се предпочита използването на move семантика при временни обекти.

Можем да инструктираме компилатора да генерира move операции експлицитно:
```c++
MyClass(MyClass&&) = default;
MyClass& operator=(MyClass&&) = default;
```
Ако обаче условията за синтезиране не са изпълнени, тези операции ще бъдат маркирани като `=delete`.

## Основни принципи на обектно-ориентираното програмиране
Основните принципи на обектно-ориентираното програмиране – инкапсулация, абстракция, наследяване и полиморфизъм - представляват концептуалната рамка, чрез която се моделират сложни системи под формата на взаимодействащи си обекти с ясно дефинирано поведение и структура.

### Капсулация

Капсулацията представлява скриване на вътрешното състояние на обекта от външния свят. Данните на обекта се предпазват от директна намеса, като достъпът до тях се осъществява чрез публични методи (интерфейс). Това позволява контрол над начина, по който обектите се използват, и защитава тяхната цялост.

В C++ капсулацията се реализира чрез дефиниране на класове или структури, като се използват модификатори на достъп:
- `private` – членовете са достъпни само от методите на същия клас;
- `protected` – достъпни са от класа и неговите наследници;
- `public` – достъпни са от всяка точка на програмата.

Важно е да се отбележи, че:
- При class членовете по подразбиране са `private`;
- При struct членовете по подразбиране са `public`;

Тази разлика може да повлияе на поведението на кода, когато не са указани явно модификатори на достъп.

```c++
class MyClass {
    int x; // по подразбиране: private
};

struct MyStruct {
    int x; // по подразбиране: public
};
```

### Абстракция

Абстракцията представлява концепция, при която на потребителя на даден обект се предоставя само необходимата за работа информация, докато вътрешната реализация остава скрита. По този начин се намалява сложността на системата, улеснява се използването ѝ и се подобрява поддръжката на кода.

Абстракцията позволява програмистът да дефинира „какво прави“ даден обект, без да разкрива „как го прави“. Това се реализира чрез дефиниране на интерфейси – набор от публични методи, чрез които се осъществява взаимодействие с обекта, без да се разкрива вътрешната логика.

В C++ абстракцията се постига чрез:
- модификатори на достъп (`private`, `protected`, `public`);
- header файлове, в които се дефинира само интерфейсът (декларации), а реализацията се скрива в `.cpp` файл;
- виртуални функции, особено чисти виртуални функции (`= 0`), чрез които се създават абстрактни класове – такива, които не могат да бъдат инстанцирани, а служат като основа за наследяване и имплементация на конкретно поведение от производни класове.

#### Пример:
Shape е абстрактен клас, който предоставя общ интерфейс (draw) за всички фигури, а Circle реализира конкретното поведение.
Потребителят на класа Shape може да работи с него чрез интерфейса, без да знае как конкретно се рисува фигурата – това е абстракция.
```cpp
class Shape {
public:
    virtual void draw() = 0; // чиста виртуална функция – абстрактен метод
};

class Circle : public Shape {
public:
    void draw() override {
        // Конкретна имплементация на draw за кръг
        std::cout << "Drawing a circle." << std::endl;
    }
};
```

-------------------
TODO
- наследяване
- множествено наследяване
- диамантен проблем
- модификатори при наследяване
- разгръщане на полиморфизъм
- хетерогенен 



### Наследяване

Наследяването е механизъм в обектно-ориентираното програмиране, чрез който се създават нови класове (наследници), базирани на вече съществуващи класове (базови).
Базовият (родителски) клас дефинира общи характеристики – член-данни и методи, които автоматично се наследяват от производния (наследник) клас.
Така се постига повторна употреба на код и организация на програмата в йерархия от класове.

Производният клас може:
- да използва наследената функционалност директно;
- да я разширява чрез добавяне на нови членове;
- или да я презаписва чрез дефиниране на свои версии на наследени виртуални методи.

#### Видове наследяване според достъпа:
В CPP се позволява три вида наследяване, които се определят от спецификатора за достъп:
```c++
class Derived : public Base { ... };     // публично наследяване
class Derived : protected Base { ... };  // защитено наследяване
class Derived : private Base { ... };    // частно наследяване
```
- При `public` наследяване
    - `public`и `protected` членовете на базовия клас запазват достъпността си.
- При `protected`
    -  `public и `protected` членове стават `protected`.
- При `private`
    - всичко става `private`.

Пояснение: По подразбиране наследяването е `private`, когато не е указано изрично.   

#### Пример за наследяване и разширяване на поведение
```c++
class Animal {
public:
    void eat() { std::cout << "Eating...\n"; }
};

class Dog : public Animal {
public:
    void bark() { std::cout << "Barking...\n"; }
};
// Класът Dog наследява метода eat() от Animal и добавя собствен метод bark().
```

### Множествено наследяване
В CPP се позволява множествено наследяване – т.е. производен клас може да има повече от един директен базов клас:
```c++
class A { ... };
class B { ... };
class C : public A, public B { ... }; // множествено наследяване
```
Предимства:
- Позволява комбиниране на функционалности от различни базови класове;
- Улеснява повторната употреба на код от независими източници.

#### Диамантен проблем (Diamond Problem)
Множественото наследяване може да доведе до двусмислици в случаите, когато един и същ базов клас се среща повече от веднъж в наследствената йерархия.
![Diamond-Problem](/01-Theory/Images/Diamond-problem.png)
```c++
//Indicate problem - Пример без виртуално наследяване

#include <iostream>

class SuperClass {
public:
  SuperClass() {
    std::cout << "SuperClass default constructor is called\n";
  }
};

class A : public SuperClass {
public:
  A() {
    std::cout << "A default constructor is called\n";
  }
};

class B : public SuperClass {
public:
  B(){
      std::cout << "B default constructor is called\n";
  }
};

class C : public A, public B {
public:
  C() {
    std::cout << "C default constructor is called\n";
  }
};

int main() {
    C obj;
}
```
Output:
```c++
SuperClass default constructor is called
A default constructor is called
SuperClass default constructor is called //<------------
B default constructor is called
C default constructor is calle
```
Конструкторът на SuperClass се извиква два пъти – веднъж чрез A и веднъж чрез B. Това означава, че обектът obj има две отделни копия на членовете на SuperClass. Ако достъпим например SuperClass::x, компилаторът няма да знае кое копие имаме предвид – възниква ambiguous behavior.

За да избегнем този проблем, използваме виртуално наследяване, което гарантира, че в наследника ще съществува само едно споделено копие на общия базов клас.
```c++
#include <iostream>

class SuperClass {
public:
  SuperClass() {
    std::cout << "SuperClass default constructor is called\n";
  }
};

class A : virtual public SuperClass {
public:
  A() {
    std::cout << "A default constructor is called\n";
  }
};

class B : virtual public SuperClass {
public:
  B(){
    std::cout << "B default constructor is called\n";
  }
};

class C : public A, public B {
public:
    C() {
        std::cout << "C default constructor is called\n";
    }
};

int main() {
    C obj;
}
```
Output:
```
SuperClass default constructor is called
A default constructor is called
B default constructor is called
C default constructor is called
```
Вече SuperClass се създава само веднъж, което елиминира двусмислието и спестява памет.

Пояснение: Когато използваме виртуално наследяване, съществуват следните особености:
- Въпреки че базовите класове (напр. A, B) могат да извикват конструктори с параметри, само най-долният производен клас (в случая C) има право да инициализира виртуалния базов клас;
- Ако SuperClass няма конструктор по подразбиране, трябва изрично да го извикаме в списъка за инициализация на C.
```c++
class SuperClass {
public:
    SuperClass(int x) { std::cout << "SuperClass(" << x << ")\n"; }
};

class A : virtual public SuperClass {
public:
    A() : SuperClass(0) { std::cout << "A()\n"; } // няма ефект!
};

class B : virtual public SuperClass {
public:
    B() : SuperClass(1) { std::cout << "B()\n"; } // няма ефект!
};

class C : public A, public B {
public:
    C() : SuperClass(42), A(), B() {
        std::cout << "C()\n";
    }
};
```
Ще бъде извикан само SuperClass(42) – инициализацията чрез A и B ще бъде игнорирана!

### Полиморфизъм
Полиморфизмът представлява един от фундаменталните принципи в обектно-ориентираното програмиране (ООП), който позволява дефиниране на унифициран интерфейс за различни типове обекти, осигурявайки гъвкавост и разширяемост на кода.

#### Видове полиморфизъм
Полиморфизмът бива два основни вида: статичен (compile-time) и динамичен (run-time). Разликата между тях се състои в момента на избор на конкретната функция, която ще бъде извикана - по време на компилация или по време на изпълнение.
- Статичен (compile-time) полиморфизъм
    - Известен още като overloading
        - Function overloading
            - Функции със същото име, но с различен брой или тип параметри.
        - Operator overloading
            - Позволява предефиниране на стандартни оператори, като `+`, `==`, `[]` и други, за да се адаптират към потребителски типове данни.
    - Изборът на подходяща функция се извършва по време на компилация.
    ```c++
    #include <iostream>

    class Base {
    public: 
    void f() const  {
            std::cout << "A::f()\n";
    }	
    };

    class Derived : public Base {
    public:
    void f() const {
            std::cout << "B::f()\n";
    }	
    };

    void func(const Base& obj) {
        obj.f();
    }	

    int main() {
    Derived* bPtr = new Derived();
        Base* aPtr = bPtr;
        
    // Early binding - Compile time
    func(*aPtr); // Base::f()
    func(*bPtr); // Base::f()
    // Въпреки че aPtr сочи към обект от тип Derived, методът f() не е виртуален,
    // затова се извиква версията от класа Base (ранно свързване).
    }
    ```
- Динамичен (run-time) полиморфизъм
    - Реализира се чрез наследяване и виртуални функции
    - Когато извикваме функция чрез указател или препратка към базов клас, се изпълнява функцията на обекта, към който сочи, дори ако той е от производен клас.
    - Изборът на функция се извършва по време на изпълнение (run-time).
    ```c++
    #include <iostream>

    class Base {
    public:
    virtual void f() const {
            std::cout << "A::f()\n";
    }	
    };

    class Derived : public Base {
    public:
    void f() const override {
        std::cout << "B::f()\n";
    }	
    };

    int main() {
        Base* ptrs[2];
        ptrs[0] = new Base(); //Base pointer to Base class object
        ptrs[1] = new Derived(); //Base pointer to Derived class object
        
        //Dynamic/Late Binding - Runtime
        ptrs[0]->f(); // Извиква Base::f(), защото обектът е от тип Base
        ptrs[1]->f(); // Извиква Derived::f(), защото обектът е от тип Derived
    }
    ```

#### Виртуални функции
Виртуалните функции осигуряват механизма за реализиране на динамичен (run-time) полиморфизъм.
Те се декларират в базовия клас с ключовата дума virtual и позволяват поведение, което зависи от действителния тип на обекта, а не от типа на указателя или референцията
- Динамичното свързване се осъществява чрез виртуална таблица (vTable) и указател към нея (vPtr), съхраняван във всеки обект с виртуални функции.
- Виртуалните функции не могат да бъдат static, тъй като изискват достъп до конкретен обект.
- За да се осигури правилно унищожаване на обекти чрез указатели към базов клас, деструкторът трябва да бъде виртуален.

Спецификатори:
- override - изрично указва, че функцията предефинира виртуална такава от базовия клас; помага за избягване на грешки.
- final - забранява по-нататъшно предефиниране на дадена виртуална функция или наследяване от даден клас.

Нека да разгледаме следната йерархия:
```c++
#include <iostream>

class Base {
public:
  virtual void f() const {
  	std::cout << "Base::f()\n";
  }

  virtual void g() const {
  	std::cout << "Base::g()\n";
  }

  void nonVirtual() const {
  	std::cout << "Base::nonVirtual()\n";
  }
};

class FirstDerived : public Base {
public:	
  void f() const override {
  	std::cout << "FirstDerived::f()\n";
  }

  void g() const override {
  	std::cout << "FirstDerived::g()\n";
  }

  virtual void h() const {
  	 std::cout << "FirstDerived::h()\n";
  }
};

class SecondDrived : public FirstDerived {
public:
  void f()const override {
  	std::cout << "SecondDrived::f()\n";
  }
};

class ThirdDerived : public SecondDrived {
  public:
    void h() const override {
  	  std::cout << "ThirdDerived::h()\n";
    }
};
```
и да създадем обекти от всеки един от тях:
```c++
int main() {
   Base baseObject;
   FirstDerived firstDerivedOject;
   SecondDerived secondDerivedObject;
   ThirdDerived thirdDerivedObject;

   Base* p = nullptr;

   p = &baseObject;
   p->f(); //static call to Base::f()
   p->g(); //static call to Base::gl()
   p->nonVirtual();  //static call to Base::nonVirtual()
   
   std::cout << "----------" << std::endl;

   p = &firstDerivedOject;
   p->f(); // Dynamic binding - SecondDerived::f()
   p->g(); // Dynamic binding - SecondDerived::g()

   std::cout << "----------" << std::endl;

   p = &secondDerivedObject;
   p->f(); // Dynamic binding - SecondDerived::f()
   p->g(); // Dynamic binding - SecondDerived::g()

   std::cout << "----------" << std::endl;

   p = &thirdDerivedObject;
   p->f(); // Dynamic binding - ThirdDerived::f()
   p->g(); // Dynamic binding - ThirdDerived::g()
}
```
На указател към базов клас (p) може да бъде присвоен адресът на обект от всеки клас, участващ в йерархията на наследяване — включително обекти от производни класове. Благодарение на механизма на динамичен полиморфизъм, чрез този указател могат да бъдат извиквани виртуални функции, като по време на изпълнение (run-time) се определя коя конкретна реализация на функцията трябва да бъде извикана в съответствие с действителния (динамичен) тип на обекта.

За да реализира това поведение, компилаторът генерира специални вътрешни структури за управление на виртуалните функции. По време на компилация, за всеки клас в йерархията, който съдържа поне една виртуална функция (или наследява такава), се създава т.нар. виртуална таблица (vtable). Това е масив от указатели към съответните виртуални функции.

Всяка инстанция на клас, който има виртуални функции, съдържа скрит указател (vptr), който сочи към виртуалната таблица на съответния клас. При извикване на виртуална функция чрез указател или препратка към базов клас, този указател (vptr) се използва за намиране на „правилната“ функция, т.е. тази, която съответства на реалния тип на обекта, а не на типа на указателя.

Така се осигурява коректно поведение на виртуалните функции и се постига динамично свързване (late binding), което е в основата на полиморфизма в обектно-ориентираното програмиране.
![V-table](/01-Theory/Images/Vtable-Diagram.png)

#### Абстрактни класове и чисто виртуални функции
Когато дадена виртуална функция няма реализация в базовия клас, тя може да бъде дефинирана като чисто виртуална чрез добавяне на = 0:
```c++
class Shape {
public:
    virtual void draw() const = 0; // чисто виртуална функция
    virtual ~Shape() = default;
};
```
- Клас, съдържащ поне една чисто виртуална функция, се нарича абстрактен.
- От абстрактни класове не могат да се създават обекти директно.
- Те служат като интерфейс за производните класове, които са задължени да реализират всички чисто виртуални функции, за да станат инстанциируеми.
```c++
class Animal {
public:
    virtual void speak() const = 0; // абстрактна функция
    virtual ~Animal() = default;    // виртуален деструктор
};

class Dog : public Animal {
public:
    void speak() const override {
        std::cout << "Woof!\n";
    }
};
```
Този пример демонстрира как абстрактният базов клас Animal дефинира поведение (speak()), което се реализира конкретно в производния клас Dog.