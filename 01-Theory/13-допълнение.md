13. Обектно-ориентирано програмиране
 Парадигма: Обекти, които взаимодейства помежду си. (консултация Димитриев)
 
Клас/структура: Съвкупност от променливи и функции, които са в една логическа структура.
 
  class Person 
  {
   public:
    char* name;
    int age;
  };
 
  Person p; - обект от този тип. 
  Структура -> инстанция 
  Клас -> обект 
 
Декларация на клас: Трябва да се изредят член-данните и член-функциите на класа. Член-данните са <тип> <име> [ = стойност]. Член-функциите са обикновени функции, които използват контекста на класа.
контекста на класа: Обекта, от който е извикана функцията.
Към член-функциите се добавя като параметър указател към този обект.
Този указател се нарича this. 
 
Конструктори:
Функция, която се извиква при създаването на обект! Служи за инициализация на член-данните
 
 - Конструктор по подразбиране / default constructor: Конструктор без параметри!!
  Ако не сме дефинирали никакви конструктори, то компилаторът създава конструктор по подразбиране!
Важно: Нужен е за създаването на масиви!!! 
Aко нямаме def constr => T arr[10] X!!       new T[10] X
 
- Копиращ конструктор - конструктор, който приема обект от същия тип и текущия трябва да стане негово копие! 
  T(const T&) 
  Компилаторът създава такъв. Можем да го забраним, ако искаме. Можем и да напишем наша имплементация. 
Компилаторът НЕ създава такъв, ако: 
  - Ако някоя от член-данните няма копиращ конструктор!
  - Ако е разписан експлицитино move конструктор. 
 
Създаденият от компилатора копи констр: Изиква копиращите конструктори на член-данните.
 
- Move конструктор
 Т(T&&) - откраднем данните от другия обект.
 Останалото е същото като при копи констр.
 
 
- Конвертиращ конструктор - конструктор, който приема един параметър!!
 
   A(int a)  
 
 
   f(const A& obj);      f(A(3)) OK      f(3) OK! 
   g(A obj)          g(A(3)) OK      g(3) OK! 
 
Ако не искаме конструктор да е конвертиращ, пишем ключовата дума explicit
 
  explicit B(int x) 
 
   f(const B&)    f(B(3)) OK!   f(3) NO! 
 
 
 
Управление на динамичната памет и ресурсите (“RAII”)
Resource acquisition is initialization
 
RAII класовете обвърват жизнения цикъл на динамичните данни и външни ресурси със своя жизнен цикъл!!
 
class String
{
   char* data;  
}
 
В конструктора инициализирате външния ресурс!!
В деструктора го освобождавате!!
 
Класове с open()/close() са примери не RAII класове!!
 
 
При дин.памет в класа, деф. кк. оп= дестр не работят коректно => трябва да ги разпишем екплицитно!
 
 
 
Методи – декларация, предаване на параметри, връщане на резултат 
Метод - функция, която е част от клас (член-функции) 
 
Има 2 вида член-функции:
Констатни член-функции - които не променят обекта и могат да се извикват от константни обекти 
 
неконстатни член-функции
 
struct Test
{
   void f() {}
   void g() const 
}
 
 ---се превръща в
 void f(Тest * const this) {}
 void g(const Тest * const this) {}
 
2. Наследяване. Производни и вложени класове.
 
   Отношения в C++:
   Композиция:   моделира has-a relationship
   Наследяване  моделира is-a relationship 
 
Пример за композиция 
 
  class Test
  {
    A obj; !!
 
   }
 
Пример за наследяване: 
 
   class Base {…};
   class Der: <начин на наследяване> Base {}; 
 
Вложени класове:
 
   class List  {
   public:
       class Node  {
            Node* next;
            int data;
 	};
 
 
   };
Node е вложен клас на List.  List::Node n;
 
 
 
Капсулация: Ограничаване на достъпа!!
Постига се, чрез модификатори за достъп. В C++ са:
public - видимо и извън класа 
protected - в класа и наследниците
private - видимо в класа
 
 
Достъп до наследените компоненти:
 
 class A 
{
    public:
       int x;
    protected:
       int y;
    private:
       int z;
};
 
class B : public A
{
    // x is public
    // y is protected
    // z is not accessible from B
};
 
class C : protected A
{
    // x is protected
    // y is protected
    // z is not accessible from C
};
 
class D : private A    // 'private' is default for classes
{
    // x is private
    // y is private
    // z is not accessible from D
}; 
 
 
 
Капсулация: Да не се позволява да се нарушат инвариантите на класа. 
Инварианта на клас - условие, което винаги е изпълнено за член-данните и можем да разчитаме на това при член-функциите
 
Как се постига? Допуска се достъп до променливите, но под контрол.
Чрез гет/сет функции ( селектори и мутатори ) 
 
гет функции:
Връщат копие/конст реф/конст указател към член-данните
 
сет функции: Позволяват модификация, но имат и валидация вътре!
 
Статични полета и методи:
Статична променлива в клас - променлива, която не е обвързана с конкретен обект!! Тя не влияе на големината на обекта!! 
Живее при паметта за глобалните променливи! 
 
 
Статични функции в клас - функции, които не е задължително да имате обект, за да ги извикате. 
Нямат достъп до член-данните (без да е подаден обект). Имат достъп до статичните член-данни! 