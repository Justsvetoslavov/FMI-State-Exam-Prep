# Тема 13: Обектно-ориентирано програмиране. Основни принципи. Класове и обекти. Наследяване и капсулация

Анотация:
- Класове и обекти.
    - Декларация на клас и декларация на обект.
    - Абстракция със структури от данни.
    - Капсулация и скриване на информацията.
    - Методи – декларация, предаване напараметри, връщане на резултат.
    - Статични полета и методи.
    - Основни видове конструктори.
    - Управление на динамичната памет и ресурсите (“RAII”).
- Наследяване.
    - Производни и вложени класове.
    - Достъп до наследените компоненти.

## Обектно-ориентирано програмиране

Обектно-ориентираното програмиране (ООП) е програмна парадигма, при която една програмна система се моделира като набор от обекти, които взаимодействат помежду си. За разлика от процедурния подход, при който програмата представлява последователен списък от инструкции, тук обектите са основните носители на логика и данни. Всеки обект е способен да получава съобщения, да обработва информация и да комуникира с други обекти.

Обектно-ориентираният подход позволява обединяването на данни и свързани с тях операции в структури, наречени класове, от които се създават обекти. Това води до по-добра организация на кода, повторна употреба, модулност и разширяемост, като същевременно улеснява четимостта и поддръжката на програмата.

## Kласове и обекти

### Клас(class)
В обектно-ориентираното програмиране класът представлява шаблон (или абстракция), по който се създават конкретни инстанции, наречени обекти.
Класът дефинира:
- член-данни (data members)
    - обикновено са асоциирани с всеки отделен обект на класa - описват състоянието на обекта;
    - изключение правят статичните членове (static members), които се споделят между всички обекти.
- член-функции (методи, member functions)
    - описват поведението на обекта.
    - работят с член-данните на класа.
    - извикват се с обект на класа
    - компилаторът преобразува всяка член-функция на дадена структура в обикновена функция с уникално име и един допълнителен параметър - константен указател към обекта.
    ```c++
    bool Point::isInFirstQuadrant() {
	    return x >= 0 && y >= 0;
    }

    // се превежда в:
    bool Point::isInFirstQuadrant(Point* const this) {     
	    //remember since this is a pointer (const) to Point we use the -> operator instead, which is equivalent to (*this).member;
	    return this->x >= 0 && this->y >= 0;
    }

    //Като забележете, че this е const указател към Point, т.е. не можем да меним this, но можем да променяме обекта, който е сочен от него (четем декларациите на указателите отдясно наляво). и съответно
    pt.isInFirstQuadrant();
    // се превежда в:
    Point::isInFirstQuadrant(&pt);
    ```
- Константни член-функции:
    - Не променят член-данните на структурата.
    - Оказва се чрез записването на ключовата дума const в декларацията и в края на заглавието(суфикс) в дефиницията им
    - Могат да се извикват от константни обекти.
    ```c++
    struct obj {
        void inspect() const;   //This member-function promises not to change *this
        void mutate();          //This member-function might change *this
    };

    void Test(obj& changeable, const obj& unchangeable) {
        changeable.inspect();   // Okay: doesn't change a changeable object
        changeable.mutate();    // Okay: changes a changeable object
        
        unchangeable.inspect(); // Okay: doesn't change an unchangeable object
        unchangeable.mutate();  // ERROR: attempt to change unchangeable object
    }
    ```
    - const индикира, че this е указател към const.
    - Член-функции, които използват const по този начин не могат да променят обекта, върху който са извикани!

Класът сам по себе си не заделя памет, тъй като представлява само описание на структурата и поведението на обектите. Памет се заделя едва при създаване на конкретни инстанции (обекти) от този клас. По този начин една програма може многократно да използва еднотипна дефиниция за създаване на множество обекти с еднаква структура, но с различни състояния.

Класовете в C++ се дефинират чрез ключовата дума class, последвана от името на класа и тяло, оградено с `{}` и завършващо със `;`. В тялото на класа се дефинират член-данни и член-функции, разделени чрез модификатори за достъп:
- private: достъпът е ограничен само до методите на същия клас;
- protected: достъпът е разрешен и за производните класове;
- public: достъпът е разрешен за всички.
По подразбиране, ако не е указано друго, членовете на клас са private. При структурите (struct) – по подразбиране са public.

#### Пример - Шаблонен клас
```c++
template<typename K, typename V>
class Pair {
private:
    K key;
    V value;

public:
    Pair() {
        key = K();
        value = V();
    }

    void setKey(K key) { this->key = key; }
    void setValue(V value) { this->value = value; }
    K getKey() { return key; }
    V getValue() { return value; }
};
```
Горният пример показва шаблонен клас, който представя двойка от ключ и стойност. Използването на шаблони позволява генерирането на класове за различни типове по време на компилация.
Уточнение: Препоръчва се член-данните да се подреждат по нарастващ размер в байтове, за да се постигне оптимално подравняване в паметта.

#### Област на класа (област на видимост)
Класовете могат да се дефинират в различни области:
- Глобално (на ниво пространство от имена)
    - класът е достъпен навсякъде в обхвата на програмата след мястото на дефиниция.
- Локално (във функция или в тяло на клас)
    - класът е достъпен само в рамките на тази функция или клас.

Ако клас е дефиниран вътре във функция, всички негови методи трябва да са inline, тъй като C++ не позволява дефиниция на функции вътре във функции (nested functions).

### Обекти
Обект е конкретна инстанция на даден клас. Всеки обект притежава собствено копие на член-данните, а методите се споделят между всички обекти, тъй като са дефинирани веднъж в паметта.

Създаване на обект в C++:
```c++
Pair<int, std::string> p;
```
Тук `Pair` е клас, `p` е обект, който ще притежава своя двойка от `int` и `std::string`.

При създаване на обекти се заделя памет, инициализираща се чрез конструктори. Конструкторите са специални методи, извиквани автоматично при създаване на обект. Всеки обект има собствен контекст, до който методите му имат достъп чрез указателя this. Той сочи към текущия обект и се използва за разграничаване между член-данни и параметри на методите.

### Аксесори и мутатори (Getters и Setters)
Аксесорите (get функции) и мутатори (set функции) са публични методи, чрез които се осигурява контролиран достъп до частните (private) член-данни на класа. Това е част от принципа на капсулацията, който ограничава директната външна манипулация на вътрешното състояние на обекта.
```c++
class Person {
private:
    std::string name;
    int age;

public:
    void setName(const std::string& n) { name = n; }
    std::string getName() const { return name; }

    void setAge(int a) { age = a; }
    int getAge() const { return age; }
};
```
Този подход позволява валидиране на стойности и поддръжка на инварианти (например: възрастта да не е отрицателна).

### Композиция и агрегация
Композицията и агрегацията са начини за моделиране на отношения между класове, при които един обект „съдържа“ друг.

#### Композиция (Composition)
Композицията представлява „силна“ връзка между обектите: ако обект A съдържа обект B чрез композиция, то B не може да съществува независимо от A.
```c++
class Engine {
    // ...
};

class Car {
private:
    Engine engine; // композиция
};
// Тук engine е част от Car, създава се и се унищожава заедно с него.
```

#### Агрегация (Aggregation)
Агрегацията е „по-слаба“ връзка, при която обектът B може да съществува независимо от обекта A. Обикновено се реализира чрез указатели или референции.
```c++
class Engine {
    // ...
};

class Car {
private:
    Engine* engine; // агрегация
public:
    Car(Engine* e) : engine(e) {}
};
// Тук Car използва Engine, но не го притежава — двигателят може да се използва и от други обекти.
```

### Конструктор
Конструкторът е специална член-функция, която се извиква автоматично при създаване на обект. Името ѝ съвпада с това на класа, няма тип на връщане и може да има параметри.
```c++
class A {
public:
    A(); // конструктор по подразбиране
    A(int x); // параметризиран конструктор
};
```

#### Видове конструктори
- По подразбиране (Default Constructor)
    - автоматично се генерира, ако не е дефиниран друг
    - Ако обект се създава без аргументи, той се извиква.
    ```c++
    A a; // default constructor
    ```
- Параметризиран (Parameterized Constructor)
    - приема параметри и се дефинира от програмиста.
    - Ако се дефинира поне един такъв, компилаторът не създава конструктор по подразбиране.
    ```c++
    A(int x) : val(x) {}
    ```
- Копиращ (Copy Constructor)
    - създава нов обект като копие на съществуващ.
    - Прилага се при предаване по стойност, връщане по стойност и инициализация чрез =.
    ```
    A(const A& other);
    ```
- Преместващ (Move Constructor)
    - приема rvalue reference (A&&) и прехвърля ресурси от подадения обект.
    ```c++
    A(A&& other) noexcept;
    ```

Допълнение: Конструкторите могат да инициализират член-данни още преди изпълнение на тялото (Инициализиращ списък)
```c++
A(int x) : val(x), name("default") {}
```

### Деструктор
Извиква се автоматично при унищожаване на обекта – при излизане от scope или при delete.
```c++
~A(); // деструктор
```
Използва се за освобождаване на ресурси (напр. delete[] arr;).
Ако не е дефиниран, компилаторът създава дефолтен деструктор, който не освобождава динамична памет.
```c++
{
    Test t; // Constructor
    {
        Test t2; // Constructor
    } // Destructor (t2)
} // Destructor (t)
```

Важно: RAII (Resource Acquisition Is Initialization) е обектно-ориентиран идиом, при който придобиването и освобождаването на ресурси се свързва с жизнения цикъл на обект. Ресурсите се заделят в конструктора и се освобождават в деструктора на съответния обект. По този начин се осигурява автоматично и надеждно управление на ресурси, включително при възникване на изключения или преждевременно прекъсване на изпълнението.


### Copy assignment operator
- Оператор= (Copy assignment operator)
    - функция/оператор, който приема обект от същия клас и променя данните на съществуващ обект от същия клас (обектът от който извикваме функцията).
```c++
Test(const Test& other); // копиращ конструктор
Test& operator=(const Test& other); // оператор =
```

При липсата на дефиниран/и копиращ конструктор и/или оператор=, компилаторът автоматично създава такива по подразбиране.

Забележка: Копиращият конструктор създава нов обект, а оператор= модифицира вече съществуващ такъв!
```c++
Test t1;
Test t2(t1);  // Copy constructor
t2 = t1;      // Copy assignment
Test t3 = t1; // Copy constructor
```

### Преместване (Move семантика)
Move семантиката позволява трансфер на ресурси от временни (rvalue) обекти, вместо тяхното копиране.
Това осигурява значително подобрение в производителността при работа с ресурсоемки обекти.
```c++
Test(Test&& other) noexcept; // Моve constructor
Test& operator=(Test&& other) noexcept; // Move assignment operator
```
Move конструкторът и операторът за преместване приемат неконстантна rvalue референция към същия тип.
Основната идея е да „откраднем“ ресурсите на other, оставяйки го в безопасно за унищожаване състояние.

Move семантиката е особено ефективна в контекста на RAII, тъй като позволява прехвърляне на собствеността над ресурси между обекти, без скъпо копиране.

#### Пример за move конструктор:
```c++
Student::Student(Student&& other) noexcept : name(other.name), age(other.age) {
	other.name = nullptr; // Оставяме обекта в неопасно за унищожаване състояние
    other.age = 0;
}
```
Така `name` поема указателя от `other.name`, без да се заделя нова динамична памет.
След това присвояваме `nullptr` на `other.name`, за да предотвратим двойно освобождаване на паметта при унищожаване.

#### Пример оператор за присвояване:
```c++
Person& operator=(Person&& other) noexcept {
    if (this != &other) {        // Проверка за самоприсвояване
        free();                  // Освобождаваме текущите ресурси

        name = other.name;       // Прехвърляме указателя към динамичната памет
        age = other.age;         // Копираме стойността на примитивния тип

        other.name = nullptr;    // Оставяме other в безопасно за унищожаване състояние
    }
    return *this;                // Връщаме текущия обект (*this) по референция
}
```
Тук се демонстрира типичният шаблон за оператор за преместване:
- Първо се освобождават старите ресурси на обекта.
- След това се „открадват“ ресурсите на временния обект other.
- Накрая other се поставя в неутрално състояние, за да не се получи двойно освобождаване на паметта в деструктора.

### Синтезирани move операции
Компилаторът може автоматично да генерира move конструктор и move оператор за присвояване, при следните условия:
- Класът няма дефинирани: copy конструктор, copy оператор или деструктор.
- Всички член-данни на класа поддържат преместване (т.е. имат move конструктор/оператор).
Ако някой от горните copy контрол методи е дефиниран ръчно, move операциите не се синтезират автоматично.

Поведение при липса на дефинирани move операции
- Ако няма налични move операции, компилаторът прибягва до copy семантика, дори при временни обекти - ...което е по-неефективно и именно затова се предпочита използването на move семантика при временни обекти.

Можем да инструктираме компилатора да генерира move операции експлицитно:
```c++
MyClass(MyClass&&) = default;
MyClass& operator=(MyClass&&) = default;
```
Ако обаче условията за синтезиране не са изпълнени, тези операции ще бъдат маркирани като `=delete`.

## Основни принципи на обектно-ориентираното програмиране
Основните принципи на обектно-ориентираното програмиране – инкапсулация, абстракция, наследяване и полиморфизъм - представляват концептуалната рамка, чрез която се моделират сложни системи под формата на взаимодействащи си обекти с ясно дефинирано поведение и структура.

### Капсулация

Капсулацията представлява скриване на вътрешното състояние на обекта от външния свят. Данните на обекта се предпазват от директна намеса, като достъпът до тях се осъществява чрез публични методи (интерфейс). Това позволява контрол над начина, по който обектите се използват, и защитава тяхната цялост.

В C++ капсулацията се реализира чрез дефиниране на класове или структури, като се използват модификатори на достъп:
- `private` – членовете са достъпни само от методите на същия клас;
- `protected` – достъпни са от класа и неговите наследници;
- `public` – достъпни са от всяка точка на програмата.

Важно е да се отбележи, че:
- При class членовете по подразбиране са `private`;
- При struct членовете по подразбиране са `public`;

Тази разлика може да повлияе на поведението на кода, когато не са указани явно модификатори на достъп.

```c++
class MyClass {
    int x; // по подразбиране: private
};

struct MyStruct {
    int x; // по подразбиране: public
};
```

### Абстракция

Абстракцията представлява концепция, при която на потребителя на даден обект се предоставя само необходимата за работа информация, докато вътрешната реализация остава скрита. По този начин се намалява сложността на системата, улеснява се използването ѝ и се подобрява поддръжката на кода.

Абстракцията позволява програмистът да дефинира „какво прави“ даден обект, без да разкрива „как го прави“. Това се реализира чрез дефиниране на интерфейси – набор от публични методи, чрез които се осъществява взаимодействие с обекта, без да се разкрива вътрешната логика.

В C++ абстракцията се постига чрез:
- модификатори на достъп (`private`, `protected`, `public`);
- header файлове, в които се дефинира само интерфейсът (декларации), а реализацията се скрива в `.cpp` файл;
- виртуални функции, особено чисти виртуални функции (`= 0`), чрез които се създават абстрактни класове – такива, които не могат да бъдат инстанцирани, а служат като основа за наследяване и имплементация на конкретно поведение от производни класове.

#### Пример:
Shape е абстрактен клас, който предоставя общ интерфейс (draw) за всички фигури, а Circle реализира конкретното поведение.
Потребителят на класа Shape може да работи с него чрез интерфейса, без да знае как конкретно се рисува фигурата – това е абстракция.
```cpp
class Shape {
public:
    virtual void draw() = 0; // чиста виртуална функция – абстрактен метод
};

class Circle : public Shape {
public:
    void draw() override {
        // Конкретна имплементация на draw за кръг
        std::cout << "Drawing a circle." << std::endl;
    }
};
```

### Наследяване

Наследяването е механизъм в обектно-ориентираното програмиране, чрез който се създават нови класове (наследници), базирани на вече съществуващи класове (базови).
Базовият (родителски) клас дефинира общи характеристики – член-данни и методи, които автоматично се наследяват от производния (наследник) клас.
Така се постига повторна употреба на код и организация на програмата в йерархия от класове.

#### Производни класове
Производен клас (или наследник) е клас, който е създаден на базата на вече съществуващ клас - базов клас. Той наследява всички публични и защитени членове (променливи и методи) на базовия клас и може да добавя нови членове или да модифицира (презаписва) наследени методи.
```c++
class Base {
public:
    void foo() { std::cout << "Base foo\n"; }
};

class Derived : public Base {  // Derived е производен клас на Base
public:
    void bar() { std::cout << "Derived bar\n"; }
};
```

#### Вложени класове
Вложени класове са класове, дефинирани вътре в друг клас (външен клас). Те служат за логическа групировка и капсулиране на свързана функционалност. Вложеният клас има достъп до публичните и защитените статични членове на външния клас, но за достъп до нестатичните членове се нуждае от обект на външния клас.

Пример:
```c++
class Outer {
public:
    class Inner {
    public:
        void display() { std::cout << "Inner class\n"; }
    };
};

// Достъп до вложения клас
Outer::Inner obj;
obj.display();
```

#### Видове наследяване според достъпа:
В CPP се позволява три вида наследяване, които се определят от спецификатора за достъп:
```c++
class Derived : public Base { ... };     // публично наследяване
class Derived : protected Base { ... };  // защитено наследяване
class Derived : private Base { ... };    // частно наследяване
```
- При `public` наследяване
    - `public`и `protected` членовете на базовия клас запазват достъпността си.
- При `protected`
    -  `public и `protected` членове стават `protected`.
- При `private`
    - всичко става `private`.

Пояснение: По подразбиране наследяването е `private`, когато не е указано изрично.   

Важно е също така, че:
- Производният клас не може да достъпва директно `private` членове на базовия клас, но може да използва публични или защитени методи за достъп.
- Наследствените методи могат да бъдат презаписвани (override) ако са виртуални.

#### Пример за наследяване и разширяване на поведение
```c++
class Animal {
public:
    void eat() { std::cout << "Eating...\n"; }
};

class Dog : public Animal {
public:
    void bark() { std::cout << "Barking...\n"; }
};
// Класът Dog наследява метода eat() от Animal и добавя собствен метод bark().
```

#### Множествено наследяване
Множественото наследяване позволява един клас да наследява от повече от един базов клас. Това означава, че наследникът получава всички публични и защитени членове (променливи и методи) на всички наследени класове.

```c++
class A {
public:
    void hello() { cout << "Hello from A\n"; }
};

class B {
public:
    void greet() { cout << "Greetings from B\n"; }
};

class C : public A, public B {
    // Наследява от A и B
};
```

### Полиморфизъм
Полиморфизмът представлява един от фундаменталните принципи в обектно-ориентираното програмиране (ООП), който позволява дефиниране на унифициран интерфейс за различни типове обекти, осигурявайки гъвкавост и разширяемост на кода.

С други думи, едни и същи действия се реализират по различен начин в зависимост от обектите, върху които се прилагат.
- Действията се наричат полиморфни;
- Реализира се чрез виртуални функции;
- Класовете, върху които ще се прилага, трябва да имат общ родител или прародител, т.е. да са наследници на един и същ клас.
- В класа се дефинира виртуален метод, съответстващ на полиморфното действие.
- Всеки клас предефинира или не виртуалния метод.
- "Активирането" става чрез указател към базов клас, на който може да се присвоят адресите на обекти, на които и да е от базовите класове от йерархията
