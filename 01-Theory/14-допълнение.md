14. Обектно-ориентирано програмиране. Подтипов и параметричен полиморфизъм. Множествено наследяване (консултация Димитриев)
 
 
 Полиморфизъм: Едно име, но различни имплементации.
 
 - Статичен / compile time polymorphism / Статично свързване 
     - функцията се определя по време на компилация.
     Пример: Function overloading, operator overloading, Шаблони 
 
 
 - Динамичен / run time polymorphism / Динамично свързване
     Постига се чрез виртуални функции. Функцията се определя не от типа на указател/референцията, а от типа на обекта, от който се извиква.
 
 
    Абстрактен метод (pure virtual function) - class Base {  virtual void f() = 0} 
   - Може да няма имплементация!!
   - Ако в класа имаме абстрактен метод, то не можем да правим обекти от него!
   - Казваме на наследника, че ако иска да не е абстрактен, трябва да презапише функцията.
 
 
Ако в клас има абстрактен метод, то той става абстрактен клас! 
 
Ако имате полиморфна йерархия (поне една вирт функция в базовия клас), задължително дефинираме деструктора като виртуален, защото вероятно ще изтриваме обектите от указател от типа на базовия клас!!
 
Масиви от обекти и от указатели към обекти.
 
Може да правим от обекти, но те трябва да са от един и същи тип!!
Основното предмиство тук е Locality - обектите са последователни в паметта!!
A arr[5];
 
Масиви от указатели към обекти - позволява да направите хетерогенен контейнер, като масивът ви е деклиран, че е от указатели към базовия клас!! 
Може да се работи с масив от различни елементи от една йерархия! 
Плюсове: Полиморфизъм!
Минус: Липса на locality 
 
Параметричен полиморфизъм. Шаблони на функция и на клас
 
Клас/функция - шаблонни. 
Пишете я веднъж и кода се дублицира за типовете, за които ще го използвате. 
 
template <class T> 
const T& max(const T& lhs, const T& rhs)
      return lhs < rhs ? rhs : lhs; 
 
Типът T трябва да има дефиниран оператор <
 
max<int>(3,4)   
max<string>("abc, "xyz") се създават имплементации на функцията max за тези типове 
 
Пример за шаблонен клас:
 
template <class T> 
class Vector {
 
private:
 T* data;
}
 
Шаблонна сепциализация: Различно поведение за определени типове. 
Т.е екплицитно разписвам специално поведение за някои типове: 
 
Пример: За сортиране, ако сортираме символи - count sort, ако е нещо друго - quick sort
 
Пример: std::vector<bool> темплейтна специализация - пази данните в bitset 
 
 
Множествено наследяване:
Един клас може да има повече от 1 базови класове
 
     Base1  Base2
         Der 
   Трябва да се внимава да няма функции и променливи с едно и също име в двата базови класа! 
 
    А 
 
  B   C
    D
   Диамантен проблем: Имаме 2 инстанции/обекта на А в обектва от тип D
В C++ е дефинирано виртуално наследяване, което се грижи B и C да споделят един обект от тип А в контекста на обект от тип D.