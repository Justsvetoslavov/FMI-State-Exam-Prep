# Teма 14:  Обектно-ориентирано програмиране. Подтипов и параметричен полиморфизъм. Множествено наследяване

Анотация:
- Виртуални функции и подтипов полиморфизъм.
    - Динамично свързване.
    - Абстрактни методи и класове.
    - Параметричен полиморфизъм.
    - Множествено наследяване.
- Шаблони на функция и на клас
- Масиви от обекти и от указатели към обекти.

## Полиморфизъм
Полиморфизмът представлява един от фундаменталните принципи в обектно-ориентираното програмиране (ООП), който позволява дефиниране на унифициран интерфейс за различни типове обекти, осигурявайки гъвкавост и разширяемост на кода.

#### Видове полиморфизъм
Полиморфизмът бива два основни вида: статичен (compile-time) и динамичен (run-time). Разликата между тях се състои в момента на избор на конкретната функция, която ще бъде извикана - по време на компилация или по време на изпълнение.
- Статичен (compile-time) полиморфизъм
    - Известен още като overloading
        - Function overloading
            - Функции със същото име, но с различен брой или тип параметри.
        - Operator overloading
            - Позволява предефиниране на стандартни оператори, като `+`, `==`, `[]` и други, за да се адаптират към потребителски типове данни.
        - Параметричен полиморфизъм (templates)
            - Осъществява се чрез шаблони (templates) на функции и класове.
            - Позволява създаването на функции или класове, които работят с различни типове без повторение на кода.
            - Използва се за реализиране на обобщени алгоритми и структури от данни.
            ```c++
            template<typename T>
            T max(T a, T b) {
                return (a > b) ? a : b;
            }
            ```
    - Изборът на подходяща функция се извършва по време на компилация.
    ```c++
    #include <iostream>

    class Base {
    public: 
        void f() const  {
                std::cout << "A::f()\n";
        }	
    };

    class Derived : public Base {
    public:
        void f() const {
                std::cout << "B::f()\n";
        }	
    };

    void func(const Base& obj) {
        obj.f();
    }	

    int main() {
        Derived* bPtr = new Derived();
        Base* aPtr = bPtr;
        
        // Early binding - Compile time
        func(*aPtr); // Base::f()
        func(*bPtr); // Base::f()
        // Въпреки че aPtr сочи към обект от тип Derived, методът f() не е виртуален,
        // затова се извиква версията от класа Base (ранно свързване).
    }
    ```
    Това се случва, защото функцията func приема параметър от тип const Base&. По време на компилация компилаторът знае само статичния тип на обекта (Base) и тъй като методът f() не е виртуален, свързването е статично и се избира Base::f().
- Динамичен (run-time) полиморфизъм
    - Реализира се чрез наследяване и виртуални функции
    - Когато извикваме функция чрез указател или препратка към базов клас, се изпълнява функцията на обекта, към който сочи, дори ако той е от производен клас.
    - Изборът на функция се извършва по време на изпълнение (run-time).
    ```c++
    #include <iostream>

    class Base {
    public:
    virtual void f() const {
            std::cout << "A::f()\n";
    }	
    };

    class Derived : public Base {
    public:
    void f() const override {
        std::cout << "B::f()\n";
    }	
    };

    int main() {
        Base* ptrs[2];
        ptrs[0] = new Base(); //Base pointer to Base class object
        ptrs[1] = new Derived(); //Base pointer to Derived class object
        
        //Dynamic/Late Binding - Runtime
        ptrs[0]->f(); // Извиква Base::f(), защото обектът е от тип Base
        ptrs[1]->f(); // Извиква Derived::f(), защото обектът е от тип Derived

        // Освобождаване на паметта
        delete ptrs[0];
        delete ptrs[1];
    }
    ```

## Виртуални функции
Виртуалните функции осигуряват механизма за реализиране на динамичен (run-time) полиморфизъм.
Те се декларират в базовия клас с ключовата дума virtual и позволяват поведение, което зависи от действителния тип на обекта, а не от типа на указателя или референцията
- Динамичното свързване се осъществява чрез виртуална таблица (vTable) и указател към нея (vPtr), съхраняван във всеки обект с виртуални функции.
- Виртуалните функции не могат да бъдат static, тъй като изискват достъп до конкретен обект.
- За да се осигури правилно унищожаване на обекти чрез указатели към базов клас, деструкторът трябва да бъде виртуален.

Спецификатори:
- override - изрично указва, че функцията предефинира виртуална такава от базовия клас; помага за избягване на грешки.
- final - забранява по-нататъшно предефиниране на дадена виртуална функция или наследяване от даден клас.

Нека да разгледаме следната йерархия:
```c++
#include <iostream>

class Base {
public:
  virtual void f() const {
  	std::cout << "Base::f()\n";
  }

  virtual void g() const {
  	std::cout << "Base::g()\n";
  }

  void nonVirtual() const {
  	std::cout << "Base::nonVirtual()\n";
  }
};

class FirstDerived : public Base {
public:	
  void f() const override {
  	std::cout << "FirstDerived::f()\n";
  }

  void g() const override {
  	std::cout << "FirstDerived::g()\n";
  }

  virtual void h() const {
  	 std::cout << "FirstDerived::h()\n";
  }
};

class SecondDerived : public FirstDerived {
public:
  void f()const override {
  	std::cout << "SecondDerived::f()\n";
  }
};

class ThirdDerived : public SecondDerived {
  public:
    void h() const override {
  	  std::cout << "ThirdDerived::h()\n";
    }
};
```
и да създадем обекти от всеки един от тях:
```c++
int main() {
   Base baseObject;
   FirstDerived firstDerivedOject;
   SecondDerivedsecondDerivedObject;
   ThirdDerived thirdDerivedObject;

   Base* p = nullptr;

   p = &baseObject;
   p->f(); //static call to Base::f()
   p->g(); //static call to Base::gl()
   p->nonVirtual();  //static call to Base::nonVirtual()
   
   std::cout << "----------" << std::endl;

   p = &firstDerivedOject;
   p->f(); // Dynamic binding - FirstDerived::f()
   p->g(); // Dynamic binding - FirstDerived::g()

   std::cout << "----------" << std::endl;

   p = &secondDerivedObject;
   p->f(); // Dynamic binding - SecondDerived::f()
   p->g(); // Dynamic binding - FirstDerived::g()

   std::cout << "----------" << std::endl;

   p = &thirdDerivedObject;
   p->f(); // Dynamic binding - SecondDerived::f()
   p->g(); // Dynamic binding - FirstDerived::g()
   p->h(); // Dynamic binding - ThirdDerived::h()
}
```
На указател към базов клас (p) може да бъде присвоен адресът на обект от всеки клас, участващ в йерархията на наследяване — включително обекти от производни класове. Благодарение на механизма на динамичен полиморфизъм, чрез този указател могат да бъдат извиквани виртуални функции, като по време на изпълнение (run-time) се определя коя конкретна реализация на функцията трябва да бъде извикана в съответствие с действителния (динамичен) тип на обекта.

За да реализира това поведение, компилаторът генерира специални вътрешни структури за управление на виртуалните функции. По време на компилация, за всеки клас в йерархията, който съдържа поне една виртуална функция (или наследява такава), се създава т.нар. виртуална таблица (vtable). Това е масив от указатели към съответните виртуални функции.

Всяка инстанция на клас, който има виртуални функции, съдържа скрит указател (vptr), който сочи към виртуалната таблица на съответния клас. При извикване на виртуална функция чрез указател или препратка към базов клас, този указател (vptr) се използва за намиране на „правилната“ функция, т.е. тази, която съответства на реалния тип на обекта, а не на типа на указателя.

Така се осигурява коректно поведение на виртуалните функции и се постига динамично свързване (late binding), което е в основата на полиморфизма в обектно-ориентираното програмиране.
![V-table](/01-Theory/Images/Vtable-Diagram.png)

### Абстрактни класове и чисто виртуални функции
Когато дадена виртуална функция няма реализация в базовия клас, тя може да бъде дефинирана като чисто виртуална чрез добавяне на = 0:
```c++
class Shape {
public:
    virtual void draw() const = 0; // чисто виртуална функция
    virtual ~Shape() = default;
};
```
- Клас, съдържащ поне една чисто виртуална функция, се нарича абстрактен.
- От абстрактни класове не могат да се създават обекти директно.
- Те служат като интерфейс за производните класове, които са задължени да реализират всички чисто виртуални функции, за да станат инстанциируеми.
```c++
class Animal {
public:
    virtual void speak() const = 0; // абстрактна функция
    virtual ~Animal() = default;    // виртуален деструктор
};

class Dog : public Animal {
public:
    void speak() const override {
        std::cout << "Woof!\n";
    }
};
```
Този пример демонстрира как абстрактният базов клас Animal дефинира поведение (speak()), което се реализира конкретно в производния клас Dog.

## Множествено наследяване
В CPP се позволява множествено наследяване – т.е. производен клас може да има повече от един директен базов клас:
```c++
class A { ... };
class B { ... };
class C : public A, public B { ... }; // множествено наследяване
```
Предимства:
- Позволява комбиниране на функционалности от различни базови класове;
- Улеснява повторната употреба на код от независими източници.

### Диамантен проблем (Diamond Problem)
Множественото наследяване може да доведе до двусмислици в случаите, когато един и същ базов клас се среща повече от веднъж в наследствената йерархия.
![Diamond-Problem](/01-Theory/Images/Diamond-problem.png)
```c++
//Indicate problem - Пример без виртуално наследяване

#include <iostream>

class SuperClass {
public:
  SuperClass() {
    std::cout << "SuperClass default constructor is called\n";
  }
};

class A : public SuperClass {
public:
  A() {
    std::cout << "A default constructor is called\n";
  }
};

class B : public SuperClass {
public:
  B(){
      std::cout << "B default constructor is called\n";
  }
};

class C : public A, public B {
public:
  C() {
    std::cout << "C default constructor is called\n";
  }
};

int main() {
    C obj;
}
```
Output:
```c++
SuperClass default constructor is called
A default constructor is called
SuperClass default constructor is called //<------------
B default constructor is called
C default constructor is calle
```
Конструкторът на SuperClass се извиква два пъти – веднъж чрез A и веднъж чрез B. Това означава, че обектът obj има две отделни копия на членовете на SuperClass. Ако достъпим например SuperClass::x, компилаторът няма да знае кое копие имаме предвид – възниква ambiguous behavior.

За да избегнем този проблем, използваме виртуално наследяване, което гарантира, че в наследника ще съществува само едно споделено копие на общия базов клас.
```c++
#include <iostream>

class SuperClass {
public:
  SuperClass() {
    std::cout << "SuperClass default constructor is called\n";
  }
};

class A : virtual public SuperClass {
public:
  A() {
    std::cout << "A default constructor is called\n";
  }
};

class B : virtual public SuperClass {
public:
  B(){
    std::cout << "B default constructor is called\n";
  }
};

class C : public A, public B {
public:
    C() {
        std::cout << "C default constructor is called\n";
    }
};

int main() {
    C obj;
}
```
Output:
```
SuperClass default constructor is called
A default constructor is called
B default constructor is called
C default constructor is called
```
Вече SuperClass се създава само веднъж, което елиминира двусмислието и спестява памет.

Пояснение: Когато използваме виртуално наследяване, съществуват следните особености:
- Въпреки че базовите класове (напр. A, B) могат да извикват конструктори с параметри, само най-долният производен клас (в случая C) има право да инициализира виртуалния базов клас;
- Ако SuperClass няма конструктор по подразбиране, трябва изрично да го извикаме в списъка за инициализация на C.
```c++
class SuperClass {
public:
    SuperClass(int x) { std::cout << "SuperClass(" << x << ")\n"; }
};

class A : virtual public SuperClass {
public:
    A() : SuperClass(0) { std::cout << "A()\n"; } // няма ефект!
};

class B : virtual public SuperClass {
public:
    B() : SuperClass(1) { std::cout << "B()\n"; } // няма ефект!
};

class C : public A, public B {
public:
    C() : SuperClass(42), A(), B() {
        std::cout << "C()\n";
    }
};
```
Ще бъде извикан само SuperClass(42) – инициализацията чрез A и B ще бъде игнорирана!

При виртуално наследяване редът на извикване на конструкторите е:
- Конструкторите на виртуалните базови класове (извикани от най-производния клас).
- Конструкторите на невиртуалните базови класове (в реда на тяхното деклариране).
- Конструкторите на член-данните (в реда на тяхното деклариране).
- Тялото на конструктора на самия клас.

## Шаблони на функция и на клас

Шаблоните (templates) са механизъм в езика C++, който позволява създаване на обобщен код. Те осигуряват параметричен полиморфизъм, позволявайки на функции и класове да работят с различни типове данни, без да се налага дублиране на кода. С други думи, шаблонът е една дефиниция, която компилаторът използва, за да генерира конкретни реализации въз основа на зададените типове по време на компилация.

### Шаблони на функции
Шаблон на функция представлява обобщена дефиниция на функция, при която типът на параметрите не е фиксиран, а се дефинира чрез параметри на шаблона.
```c++
template <typename T>
T функция_име(T параметър1, T параметър2);
```
- template - ключова дума, указваща, че следва шаблон.
- typename T - определя параметър на шаблона, който ще бъде заместен с конкретен тип при извикване на функцията.

Може да се използва и ключовата дума class вместо typename - двете са взаимозаменяеми в този контекст.

```c++
template <typename T>
T sum(const T& a, const T& b) {
    return a + b;
}
```
Тази функция работи с всеки тип, който поддържа операцията + — например int, double, std::string и др.
```c++
int main() {
    std::cout << sum<int>(2, 3) << std::endl;          // Явно указване на типа
    std::cout << sum(2.5, 3.1) << std::endl;           // Неявно определяне на типа (type deduction)
}
```
Компилаторът генерира конкретна реализация на функцията чрез подмяна на T с подадения тип. Този процес се нарича инстанциране на шаблон.

### Шаблони на класове
Шаблон на клас позволява дефиниране на клас, който може да оперира с произволен тип данни. Подобно на функциите, вместо да създаваме отделни класове за различни типове (IntStack, DoubleStack и т.н.), можем да използваме един шаблонен клас Stack<T>.
```c++
template <typename T>
class ИмеНаКлас {
    T данни;
public:
    void set(const T& value);
    T get() const;
};

// Пример:
template <typename T>
class Box {
private:
    T value;
public:
    void set(const T& val) { value = val; }
    T get() const { return value; }
};

// Използване:
int main() {
    Box<int> intBox;
    intBox.set(42);
    std::cout << intBox.get() << std::endl;

    Box<std::string> strBox;
    strBox.set("Hello");
    std::cout << strBox.get() << std::endl;
}

// При компилация се създават конкретни реализации на класа за типа int, std::string и т.н.
```

### Параметри на шаблона
Шаблоните могат да имат:
- Типови параметри (typename T)
- Нестойностни параметри (например цяло число):
```c++
template <typename T, int size>
class Array {
    T data[size];
};
```

### Предимства на шаблоните
- Позволяват писане на обобщен код, който може да работи с различни типове.
- Подобряват реюзабилността и гъвкавостта на кода.
- Осигуряват type safety, тъй като типовете се проверяват по време на компилация.
- Позволяват създаване на контейнери (като std::vector, std::map и др.) в стандартната библиотека на C++ (STL), които са базирани на шаблони.

### Ограничения и особености
- Шаблоните не могат да бъдат разделени на .h и .cpp без използване на специални техники, защото компилаторът трябва да вижда цялата дефиниция при инстанциране.
- Ако даден тип не поддържа операция, използвана в шаблона (например +, ==), ще възникне грешка при компилация.
- Може да се създават специализации на шаблон — т.е. специално поведение за конкретен тип.

## Масиви от обекти и от указатели към обекти.
Можем да създаваме масиви не само от базови типове (като int, char и др.), но и от потребителски дефинирани типове (обекти от класове). Съществуват различни варианти за създаване на такива масиви:
- Статични масиви от обекти
- Динамични масиви от обекти
- Масиви от указатели към обекти (както статични, така и динамични)

Всеки от тези варианти има свои специфики по отношение на създаване, използване и управление на паметта.

### Статичен масив от обекти
```c++
class A {
public:
    A() { std::cout << "Constructor\n"; }
    ~A() { std::cout << "Destructor\n"; }
};

int main() {
    A arr[5];
}
```
Обяснение:
- Създаваме масив с фиксирана дължина 5 от обекти от тип A.
- Компилаторът извиква конструктора по подразбиране 5 пъти – по веднъж за всеки елемент.
- Когато програмата напусне обхвата на функцията main, за всеки от елементите автоматично се извиква деструктор.
- Паметта се управлява автоматично (на стека).

Характеристики:
- Обектите са плътно разположени в паметта.
- Не може да се използва различен конструктор за отделни елементи.
- Размерът е фиксиран по време на компилация.

### Статичен масив от указатели към обекти
```c++
class A {
public:
    A() { std::cout << "Constructor\n"; }
    ~A() { std::cout << "Destructor\n"; }
};

int main() {
    A* arr[5];  // Масив от 5 указателя

    arr[0] = new A();  // заделяме памет динамично
    arr[2] = new A();

    delete arr[0];
    delete arr[2];
}
```
Обяснение:
- arr е масив от пет указателя, но без автоматично създаване на обекти.
- Само на някои указатели присвояваме обекти в динамичната памет с new.
- За всеки създаден обект трябва ръчно да извикаме delete, за да освободим паметта.
- Ако пропуснем, ще възникне изтичане на памет (memory leak).

Характеристики:
- Гъвкавост - можем да използваме различни конструктори за отделни елементи.
- Изисква внимателно управление на паметта.
- Самият масив (arr) е разположен в статичната памет (стек), но обектите – в динамичната памет (heap).

### Динамичен масив от обекти
```c++
class A {
public:
    A() { std::cout << "Constructor\n"; }
    ~A() { std::cout << "Destructor\n"; }
};

int main() {
    A* arr = new A[5];   // динамичен масив от 5 обекта
    delete[] arr;        // освобождаване на паметта
}
```
Обяснение:
- Създаваме масив от обекти в динамичната памет чрез new[].
- Компилаторът автоматично извиква конструктора по подразбиране за всеки елемент.
- При извикване на delete[]:
    - Извиква се деструктор за всеки елемент.
    - Освобождава се цялата заделена памет.

Характеристики:
- Размерът на масива може да бъде променлив (определя се в runtime).
- Всички обекти използват един и същи конструктор.
- Изисква delete[] (а не просто delete), за да се извикат коректно всички деструктори.

### Динамичен масив от указатели към обекти
```c++
class A {
public:
    A() { std::cout << "Constructor\n"; }
    ~A() { std::cout << "Destructor\n"; }
};

int main() {
    A** arr = new A*[5];  // масив от указатели

    arr[0] = new A();     // динамично създаване на обект
    arr[2] = new A();

    delete arr[0];
    delete arr[2];
    delete[] arr;         // освобождаваме само масива от указатели
}
```
Обяснение:
- arr е указател към масив от указатели към обекти от тип A.
- Паметта за самите указатели се заделя с new A*[5].
- Отделно създаваме самите обекти с new A().
- Трябва поотделно да изтрием всеки създаден обект, след което да изтрием масива от указатели.

Характеристики:
- Позволява най-голяма гъвкавост – различни конструктори, различен живот на обектите.
- Най-труден за управление – лесно може да се допусне изтичане на памет.
- Подходящ при сложни структури от данни (например двумерни масиви, списъци и т.н.).