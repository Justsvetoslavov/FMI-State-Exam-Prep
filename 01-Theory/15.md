# Структури от данни. Стек, опашка, списък, дърво. Основни операции върху тях. Реализация.

Имплементациите са в папка Data-Structures на root ниво

## 1. Структури от данни - дефиниране на понятието

### Структура от данни
- Структура от данни - организиране на данни в паметта, което позволява ефективно съхранение и достъп до тях.
- Абстрактна тип данни (Abstract data type) - Концептуален модел, който дефинира множество от операции и поведение на структура от данни, без да специфицира как те трябва да бъдат имплементирани и как данните им да бъдат представени в паметта. Това позволява един тип абстрактни данни да има различни реализации и респективно различна ефективност.

Видове структури от данни:
- Според способността за промяна на размера
    - статични
    - динамични
- Според връзките между елементите:
    - линейни
    - нелинейни
- Според начина на достъп до елементите:
    - последователни
    - директни

// **Note:** Алгоритъм - не е записано в темата, но според мен трябва да се обясни с две думи, понеже надолу в темата се използват сложности за операциите при структурите

### Алгоритъм
- Алгоритъм - последователност от стъпки, които се изпълняват за решаване на даден проблем.

### Сложности
- Сложност - мярка за количеството на ресурси (време, памет), които алгоритъмът изисква за изпълнение.

Видове сложности:
- Сложност на алгоритъм по време - описва как броят на елементарните операции, необходими за изпълнение на алгоритъма, нараства спрямо размера на входа
- Сложност на алгоритъм по памет - описва как количеството памет, необходимо за изпълнение на алгоритъма, нараства спрямо размера на входа

- Видове сложности:
    - Worst Case - това ще разглеждаме в рамките на темата
    - Average Case
    - Best Case

Worst case се записва с
- Big O нотация

Основни сложности:
- O(1) - константна сложност
- O(log n) - логаритмична сложност
- O(n) - линейна сложност
- O(n log n) - линейно логаритмична сложност
- O(n^2) - квадратична сложност
- O(2^n) - експоненциална сложност
- O(n!) - факториална сложност

## 2. Списък
### Логическо описание
- Линейна структура от данни, чиито данни не са наредени последователно в паметта, а всеки елемент има указател към следващия.
### Списък с една и две връзки
#### Списък с една връзка
- Всеки елемента има указател към следващия елемент

Елемент на списъка се нарича Node (възел) и съдържа:
```c++
template<typename T>
struct Node {
    T data; // данните, които съхранява елемента
    Node<T>* next; // указател към следващия елемент
};
```
#### Списък с две връзки
- Всеки елемент има указател към следващ и предишен елемент

Елемент на списъка се нарича Node (възел) и съдържа:
```c++
template<typename T>
struct Node {
    T data; // данните, които съхранява елемента
    Node<T>* next; // указател към следващия елемент
    Node<T>* prev; // указател към предишния елемент
};
```

#### Бонус (overkill) - частен случай - XORLinkedList
- Всеки елемент има указател към следващия и предишния елемент, но указателите са XOR-ирани, което позволява да се спести памет, но прави обхождането по-трудно за имплементиране.
### Характеристики на двете имплементации
#### Списък с една връзка
- Можем да обхождаме само в една посока
- един Node заема памет:
    - за данните (в зависимост от типа)
    - за указателя към следващия елемент
#### Списък с две връзки
- Можем да обхождаме в двете посоки
- един Node заема памет:
    - за данните (в зависимост от типа)
    - за указател към следващия елемент
    - за указател към предишния елемент
### Сложност на операциите - добавяне, премахване, намиране на елемент
### Имплементация на двете реализация

## 3. Стек
### Логическо описание.
- Линейна структура от данни, която следва принципа LIFO (Last In First Out) - последният добавен елемент е първият, който ще бъде премахнат.
- Стекът е абстрактна структура от данни, която позволява добавяне и премахване на елементи само от края му.
- Може да се достъпи само последно добавения елемент.
### Характеристики на статична, динамична и свързана реализация
- Статична реализация - използва масив с фиксиран размер, който не може да се променя по време на изпълнение. Ограничение е, че ако стекът е пълен, не може да се добавят нови елементи.
- Динамична реализация - използва динамично заделяне на памет, което позволява стекът да расте и се свива по време на изпълнение. Тоест ако текущо заделената памет се напълни елементи, стекът се разширява(като се заделя нова по-голяма памет), след което елементите се копират в новата памет, а старата се освобождава.
- Свързана реализация - използва свързани елементи (може да се използва вътрешно linked list), където всеки елемент има указател към следващия. Това позволява динамично добавяне и премахване на елементи, без да се налага да се заделя голяма памет предварително.
### Сложност на операциите - добавяне, премахване, намиране на елемент.
### Имплементация на трите реализации

## 4. Опашка
### Логическо описание
### Характеристики на статична, динамична и свързана реализация
### Сложност на операциите - добавяне, премахване, намиране на елемент
### Имплементация на трите реализации

## 5. Дървовидни структури от данни - кореново дърво и двоично кореново дърво
### Логическо описание
### Начини на представяне в паметта
### Имплементация на кореново дърво или двоично кореново дърво

## 6. Двоично кореново дърво за търсене
### Логическо описание
### Начини на представяне в паметта
### Сложност на операциите - добавяне, премахване, намиране на елемент
### Имплементация на двоично кореново дърво за търсене
