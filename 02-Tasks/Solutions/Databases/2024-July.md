# Задача 1:
```sql
SELECT code, price, maker
FROM PC
LEFT JOIN PRODUCT ON PC.model = PRODUCT.model
WHERE PC.model LIKE 'A%2' OR PC.model IS NULL
```

# Задача 2:
Верен отговор - В)
```sql
SELECT maker
   FROM Product p
   WHERE type = 'Laptop'
     AND EXISTS (SELECT *
                 FROM Product
                 WHERE type = 'PC'
                   AND maker = p.maker)
   GROUP BY maker
   HAVING COUNT(*) >= 2;
```
Тази заявка изпълнява всички изисквания на задачата стъпка по стъпка:
- FROM Product p WHERE type = 'Laptop': Първоначално заявката избира само редовете за продукти, които са лаптопи. Това подготвя данните за второто условие (броят на лаптопите).
- AND EXISTS (...): Това е ключовата част за първото условие.
    - EXISTS проверява дали вложената заявка връща поне един ред.
    - Вложената заявка (SELECT * FROM Product WHERE type = 'PC' AND maker = p.maker) е корелираща. За всеки ред с лаптоп от външната заявка, тя проверява: "Съществува ли (EXISTS) запис за продукт, който е 'PC' и е от същия производител (maker = p.maker)?".
    - Така EXISTS филтрира и оставя само лаптопите на производители, за които е сигурно, че произвеждат и поне един компютър.
- GROUP BY maker: След като са филтрирани само редове за лаптопи, чиито производители правят и компютри, заявката ги групира по производител.
- HAVING COUNT(*) >= 2: Накрая, HAVING клаузата филтрира групите. Тъй като вече работим само с редове за лаптопи, COUNT(*) брои колко лаптопа има във всяка група (за всеки производител). Условието >= 2 гарантира, че остават само производителите с поне два модела лаптопи.

## Oбосновка за другите:
A) Грешна употреба на COUNT и INTERSECT
```sql
(SELECT maker FROM Product WHERE type = 'PC' AND COUNT(model) >= 1)
INTERSECT
(SELECT maker FROM Product WHERE type = 'Laptop' AND COUNT(model) >= 2);
```
Основна грешка: Не можете да използвате агрегатна функция като COUNT() в WHERE клауза. WHERE филтрира редове преди групиране, докато COUNT() работи върху група от редове. Правилното място за условие върху агрегатна функция е в HAVING клаузата, която изисква GROUP BY. Тази заявка ще върне синтактична грешка.

Б) Множество грешки
```sql
SELECT DISTINCT maker FROM Product WHERE type = 'PC'
AND maker = (SELECT maker FROM Product GROUP BY maker HAVING COUNT(maker) >= 2 AND type = 'Laptop');
```
Грешка 1: Вложената заявка ще върне грешка. Условието AND type = 'Laptop' е в HAVING клаузата, но type не е нито в GROUP BY, нито е част от агрегатна функция.

Грешка 2: Операторът = очаква вложената заявка да върне точно една стойност. Вложеният SELECT е проектиран да връща списък от производители, което би довело до грешка "subquery returned more than 1 value". Правилният оператор би бил IN, а не =.

Грешка в логиката: Структурата е объркана и не съответства на изискванията.

Г) Грешна логика с EXCEPT
```sql
(SELECT maker FROM Product WHERE type = 'Laptop' GROUP BY maker HAVING COUNT(*) >= 2)
EXCEPT
(SELECT maker FROM Product WHERE type != 'PC');
EXCEPT премахва от резултата на първата заявка всички резултати, които се съдържат във втората.
```
Първа заявка: Правилно намира производителите с 2 или повече лаптопа.

Втора заявка: WHERE type != 'PC' означава WHERE type = 'Laptop' (тъй като в схемата има само два типа). Така тя намира всички производители на лаптопи.

Резултат: Заявката взема производителите с 2+ лаптопа и след това премахва от тях всички производители на лаптопи. Крайният резултат ще бъде празен или напълно грешен, защото премахва точно производителите, които се опитваме да намерим.