Нека са дадени следните дефиниции:
```c++
class foo {
public:
    foo(int) {}
};

void g(foo) {}
void f(int) {}
```

Срещу всеки от изразите посочете (като напишете "да"или "не") дали ще се компилира:
- g(5)
- f(foo(5))
- foo('a')

Отговор:
- g(5) - Да
- f(foo(5)) - Не 
- foo('a') - Да 

Oбосновка:
- g(foo) приема параметър от тип foo по стойност. 5 е int, а foo има конструктор foo(int), така че може да се създаде временен обект foo(5) и да се предаде на g. Това е неявна конверсия и е позволена.
- (int) приема int, а foo(5) е обект от тип foo. Обратната конверсия (от foo към int) не е дефинирана, тъй като в класа foo няма оператор за преобразуване към int, така че това няма как да се компилира.
- 'a' е символ (тип char), но може неявно да се преобразува до int.
Тъй като foo има конструктор foo(int), компилаторът ще извика този конструктор с 'a', преобразуван до int.


