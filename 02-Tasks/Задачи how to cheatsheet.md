Oт Терзиев:

УП
Просто пререшаваш всичко през годините
Post fix ++ е с приоритет 2
Prefix ++ и * са с приоритет 3
Prefix++ и * са дясно асоциативни
++-овете искат lvalue
Пример за компилационна грешка (prefix ++ requires lvalue)
	int a = 3;
	++(a)++;
Ptr[3] ⇔ 3[ptr] ⇔ *(ptr+3)
010 - octa literal
0b1 - binary literal
0xf3 - hex literal
5. ⇔ 5.0
strstr(const char* str1, const char* str2) - връща дали низ е подниз на друг:
Ако е връща на кой индекс почва срещането
Ако не връща std::string::npos


ООП
Просто пререшаваш всичко през годините
Полиморфизъм се осъществява само чрез * и референции, в другите случаи не се ходи до виртуална таблица и свързването е статично
Виртуален деструктор
Виртуална функция в конструктор на базов клас - вика base без значение от наследник
Stringstream за split-ване
std::geline(поток, std::string)
СДА
Просто пререшаваш всичко през годините
Гледайки решенията не винаги се целят за най-доброто решение, а да работи
БД
Понякога обратната заявка е по-лесна за писане
Много често на б) в примерите не се покриват null-ове
Ползват се единични кавички
NULL се проверява с IS NULL
Wildcards - ‘Star %_’
JOIN on <expression> - този expression тук прави филтрация преди join

УК
Таблица за вземане на решения - обикновено ще е с 4 условия
Стъпка 1:
Идентифицираме условия и следствия
C1…Cn, E1….En 
Всички условия да не са изпълнени се представя, като всички да са false, няма нужда от отделно условие
Може да се добави допълнително следствие En+1 за 0(тоест нищо не следва)

Стъпка 2:
Условията и следствията се изброяват в таблицата с решения (попълва се първата колона и checksum ред)

Стъпка 3:
броят комбинации 2^условия в примера 16
Стъпка 4:
Rfk = 2^условия/2^k => с колко True-та почва реда
Rf1 = 2^4/2 => 8

Стъпка 5:
Определяме следствията от всяко правило
Стъпка 6:
Определя се очаквания резултат от изпълнение на всяко действие => допълваме таблицата за всеки case

Checksum == колко кейса покрива колоната
Стъпка 7:
Търсим къде съвпадат 3 реда в условията и се получава един и същ резултат, т.е. 4тото условие не е от значение


Класове на еквивалентност и гранични стойности
Винаги са някакви очевидни от условията разграничения между стойностите, тип м/у x и y получаваш отстъпка 1, между y + 1 и z отстъпка 2
В този пример има 2 класа на екв X до Y и Y+1 до Z
Гранични стойности +-1/0 около границите на определените класове на еквивалентност, т.е. Ако имаме x до y, гранични стойности са x -1, x, x + 1, y -1, y, y
Редуциране на сценариите свързани с граничните стойности - може единствено, когато граничните стойности са винаги върху един и същ компонент на системата (real world пример да си тествам string-a и във всеки unit test да проверявам length != 0)
Граф на управляващия поток
Графът е съставен от:
Node за Начало
Node за Край
Node за Израз
Node за Condition
Тук се случва разклоняването
Всяко разклоняване трябва после да се събере в друг node

Последователност:
Асоциираме обработващите възли с изразите за присвояване и извикване на функции
Асоциираме възлите за взимане на решения с израз за условие if then else
Създаване на възли за разклонения и асоцииране с изразите за проверки и цикли
Асоцииране на началния и крайния възел с първи и последен израз

Въпроси на тази задача:
Покритие на изрази - представете си го като line coverage - да се мине през всеки ред
Покритие на условия - да се мине по всяко ребро, което излиза от if възел!
Обикновено са нужни по-малко тестови сценарии за покритие на изразите, отколкото но условия!!

Ортогонална матрица
Винаги се дава матрицата с девет реда
Стъпка 1: 
Определяне на независимите променливи - фактори 
Стъпка 2:
Определяне на максималния брой стойности за всички променливи и взимане на макса (ако имам такива с 2 и с 3 => 3) - нива
Стъпка 3:
Избира се ортогонален масив 

Всяка колона има зависимост, последните две са shift-ване на първи/последен елемент

Стъпка 4:
Свързване на променливите с факторите и стойностите с нивата на масива.
Т.е. Да кажа, че 1 в първа колона отговаря на ….и т.н.

Стъпка 5:
Фактор X и Фактнор Y има три специфицирани стойности в масива, но съответстващата променлива има 2 възможни стойности. Неасоциирани нива се запълват със стойностите на променливите, като се редуват отгоре надолу.

Също, ако за фактор X изберем произволнатата променлива да бъде стойността 3, то за фактор Y не трябва да избираме пак 3, а друго число от масива например 2

Стъпка 6: Генерират се тестови сценарии


САРС
Винаги е декомпозиция на модулите

Почти винаги в задачата трябва да се включи следното като модул или обосновка:
Винаги има един голям модул System, обхващащ всичко
Ако в задачата трябва софтуер да бъде разположен на други устройства се прави и друг голям модул извън System, който се отнася за софтуера на устройствата.
Устройствата могат да имат CommunicationModule за комуниция със System
Когато потребител/админ ще трябва да променя нещо => UI модул в system
Ако ще има няколко UI-а се правят подмодули към него и за Desktop, Mobile, Admin…
Винаги в обосновката се записва следното, но НЕ ЗНАМ ЗАЩО не се изобразява:

Когато имаме потребители имаме User Management модул с Authentication и Authorization подмодули, може и login и register подмодули
За сигурност може да се спомене за криптиране на данните
Availability - постига се с load balancer и реплики
Преди 2024 - добавят модул за synchronization между репликите в system

След 2024 - казват, че това не се разглежда от модулната декомпозиция и само се философства в за load balancer и реплики


АСИ
Кръгчетата са случаи/действия
Наследяване - наследяване на функционалности

Include vs extend
Extend - разширява/допълва функционалност, стрелката е към функционалността
Include - какво е нужно за действието, стрелката е към нужното

За задачата е нужно добро дефиниране на актьорите
Обикновено банки, администрации, paypal, университети и подобни са актьори

Студент получава заявка, extend, защото може да я приеме, но за действието е нужно одобрение от друг актьор

Разделяне на два вида функционалност

УПР
Тоя шит няма да го има лятната
Заинтересовани лица:
Обща култура
Външни и вътрешни;
Работни пакети:
Всяка задача трябва да дава краен резултат
Абсолютно винаги
РП1 Анализ на областта - проучване, за да се извлекат и формулират изискванията
РП 2 - разработване на квото е
….
РП n - 1 - комуникация с клиента - валидиране на изискванията, семинари, тестване,  
Рп N: управление на проекта/изискванията - планиране и контрол, изпълнява се по време на целия проект, срещи и комуникация

Материални и нематериални ресурси
РП1 - анализатори, специалисти, офис конусмативи
РП2 - програмисти, закупуване на сървър и техника
РПn-1 - КЕТЪРИНГ, лектори, зали, материали, офис консумативи, реклами
РПn - мениджър, финансист, персонал, офис консумативи

Алгебра
Първата подточка е обикновено ранг на матрица
Правиш гаусов вид => подглавния диагонал всичко да е нули
Ламбдите нарочно ги слагаш на последния/последните два реда
Обикновено става, че ранга на матрицата за L = X е размерността на първоначалната минус 2, а при L != x - е размерността на първоначалната минус 1
X от предната точка обикновено го има в другите подточки на задачата

Dim - броя вектори в базиса = n (броя променливи) - r (ранга на матрицата)

При хслу получаваш dimW < от размерността на първоначалната, пример с 5 променливи:
 
От тук изразяваш общия вид на решението на системата като полагаш n - r  променливи и получаваш нещо с p и q (понякога и само с p).
След това изразяваш фср като веднъж p = 1(или друго по-удобно число) и q = 0 и другия случай p = 0 и q = 1 (или друго по-удобно число) (ако е само p съответно p = x, където x е удобно)
Така получаваме ФСР - векторите u1 и u2 образуват ФСР 

Когато имаме подточка някакъв вектор (𝐚 = (1, 𝛼, 12, 𝛽, 1)) да принадлежи на W (пространството от решения) - просто заместваме и изразяваме a и b


Системата е съвместима, ако r(A) = r(разширено A) тоест с стълба отдясно на равно
Тука обикновено използваме направо разджурканата матрица и пак получаваме случаи за ламбда

Друг начин на изразяване на съвместимост , взимаме два лнз вектора от първоначалната е и казваме, че б е тяхна линейна комбинация
Статистика
По подточки
- вариации, комбинации, пермутации
- очакване, дисперсия, таблица на разпределение

	- разписваш ги с параметри, за да получиш точки, ако си объркал горното
- геометрично/биномно или условна вероятност
- вероятността 𝐴 да се сбъдне поне веднъж да е по-голяма от 0,999 (например)
- Обикновено на тази подточка трябва да решиш обратното т.е.				1 - P(да не се сбъдне) < 0.001

Формули:

Пермутации - Броят на всички възможни начини на подреждане на N–елементи 
Pn = n!
Вариации -  по колко начина да подредя 2 топчета от 5 (наредбата има значение)

Комбинации - по колко начина да изтегля 2 топчета от 5 (наредбата няма значение)

Условна вероятност

Таблица на разпределение:

Очакване и дисперсия (General):



Геометрично и биномно: (1-p=q)


ДСТР
Описвам само тези типове, понеже другите са тоталка.

Нерегулярни езици: (a^n).(b^n), a^(p^2)

Трябва да покажем, че език е нерегулярен.
Разглеждаме езика L’, който ни е даден изразен чрез други регулярни езици. Изразяваме го чрез регулярни език - обикновено с a*, a*b.
Допускаме, че е регулярен => трябва да изпълнява pumping лемата.
Ако w принадлежи на L и дължината на w е по-голяма от някакво p > 0 => съществуват x y z такива че w = xyz и |xy|<=p |y|>=1
=> x(y^i)z принаджлежи на L’
И сега трябва да се вземе така дума, че това да не е изпълнено.

Най-често се чупи за i = 0, i = 2


Трябва да покажем, че език е регулярен => построяваме автомат, който показва езика.
ДИС
Я се падне, я не се

Интегриране по части


Справяне с правилна рационална функ

Като има корени полагаме и ползваме навсякъде t^n
субституция

Понижаване на степента cos^2 (x) = (1 + cos(2x))/2
sin^2(x) = (1 - cos2x)/2 

