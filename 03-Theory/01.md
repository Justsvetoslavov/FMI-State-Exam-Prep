1. Графи. Дървета. Обхождане на графи. (от консултация на А.Димитриев)
 
def:  Обикн. (не мулти) неор. граф
 
G = <V,E>  V - върхове 
  Е - ребра ??
 
V2 = { {v_i, v_j} | vi, vj in V } (всички възможни ребра)
 
E <= V2 
 
Забележка: В тази дефиниция не се позволяват примки !
 (Ако искате примки  E <= V2 U V1 ) 
 
def:  Обикн. (не мулти) ориентиран граф
  G = <V,E> 
   E <= V x V
 
Мултиграф неориентиран: 
  G = <V, e, f> 
   V - Върховете
   Е - ребрата 
   f : E -> V2
 
Мултиграф ориентиран: 
  G = <V, e, f> 
   V - Върховете
   Е - ребрата 
   f : E -> V x V
 
  Неор граф -> път и цикъл
  Ор граф -> маршрут и контур 
 
 
Б.О.О. ще говорим в контекста на Неор граф 
 
 Път в неор граф:  v_1 e_1 v_2 e_2 ... v_k
                    v_i in V
                    e_i in E 
         По избраната дефиниция за граф:
	  е_i е ребро между v_i и v_{i+1} 
Прост път, ако няма повтарящи се компоненти. 
 
 
 Цикъл в неор. граф: Път, в който първият и последният елемент съвпадат. 
  Прост цикъл: Път, който е цикъл и няма повтарящи елементи освен първия и последния.
 
Свързаност и свързани компоненти на граф:  // (в контекста на неор. графи) 
   G = <V,E> неор граф.  (Б.О.О говорим за обикновен граф) 
 
  Дефинираме релация на свързаност: 
   Conn <= V x V 
   <v_i, v_j>  in  Conn  <=> Съществува път от v_i към v_j
  Наблюдение:
  Conn има три свойста:
  1. рефлексивност:                  // за всяко а  <a,a> in R
    всяко v \in V (<v,v> in Conn) 
   Всеки връх има път към себе си. 
  2. Симетричност                    // <а,b> in R  => <b,a> in R 
   всяко vi, vj  <vi, vj> \in Conn => <vj, vi> \in Conn 
   (Ако има път от vi до vj, то има път и от vj до vi) 
    Идва от това, че графът е неор!!!
 
  3. Транзитивност                  // (<a,b> \in R  <b,c> \in R) => <a,c> \in R  
 
   (ако има път от v_i до v_j и има път от v_j до v_t, то има път и от v_i до v_t)
   Аргументация: Ако конкатенирате пътищата от v_i до v_j с v_j до v_t, получавате път
  от v_i до v_t.
 
 След като Conn e реф, сим и тр => Conn е релация на еквивалентност. 
  => Conn се разбива на класове на еквивалентност. 
Класовете на еквивалентност са свързаните компоненти на графа. 
  Граф е свързан <=> има точно 1 свързана компонента. 
 
 
Дефиниция на дърво и кореново дърво
 
Деф 1. Дефиниция за дърво: Свързан неор. граф без цикли. 
 
Деф 2. Дефиниция за кореново дърво: 
  Индуктивна дефиниция:
 База: < {v}, o> е дърво 
 
 Нека Т = <V, E> е дърво. 
  Тогава и T' = <V U {x} ,  E U {{x, v}} >
               x \not in V     v \in V 
 
Твърдение: Деф1 и деф2 са еквивалентни
Твърдение: Ако T = <V,E> е дърво, то |V| = |E| + 1
 
Доказателство, че всяко кореново дърво е дърво и |V|=|E|+1:
 
Трябва да покажем, че всяко кор. дърво е свързано, няма цикли и |V|=|E|+1. 
 
Структурна индукция по построението на кореновото дърво.
 
 База: < {v}, o>  
       - Свързан (само един връх) 
       - Няма цикли (няма ребра) 
       - |V| = 1 = |E| + 1 = 0 + 1
 
 Нека T е кор. дърво и горните твърдения са изпълнени. 
  Разглеждаме: T' = <V U {x} ,  E U {{x, v}} >
     Твърдя, че T'
    - Свързан: От. и.п T e свързан => от върхът, с който x(новият връх) е свързан 
    са достижими всички върхове в T. Следователно те са достижими и от x.
     Няма цикли: От и.п в T няма цикли. x не участва в цикъл, защото има само едно ребро. 
     |V U {x} | = | E U {{x, v}} | + 1
    От ип: |V| = |E| + 1
       |V U {x} | = |V| + 1 = |E| + 1 + 1 = |E U {{x, v}}| + 1
 
Покриващо дърво на граф. 
Нека G = <V,E> неор граф
  T = <V, E'>  E' <= E - дърво - Тогава T е покриващо дърво на G. 
 
 Обхождане на граф в ширина и дълбочина. 
 - Обхождане на върховете в определена последователност. 
 
 BFS  /  DFS 
 
   BFS (обхожда елементите по нива) :  
 
 
 BFS : G -граф, v - нач връх. 
 
   Q - queue 
   Visited 
 
   q.enqueue(v)
   visited[v] <- true
 
   while q is not empty
       curr <- q.dequeue();
       //handle curr 
      for(u in adj[curr])
       {
           if(not visited[u]) 
              q.enqueue(u);
              visited[u] <- true;
       }       
 
 
DFS : G -граф, v - нач връх. 
 
 
DFS-rec : G, v
 
   visited - bool array 
   visited[v] <- true; 
   handle(v); 
 
   for(u : adj of v)
      if(not visited[u])
           DFS-rec(u);
 
 
 
DFS: 
   visited
   for v from G
     DFS-rec(v, visited);
 
 
Ойлерови обхождания на НЕОР. мултиграф
  Ойлеров път (КОЙТО НЕ Е ЦИКЪЛ) - път, в който се обхождат всички ребра точно веднъж.
  Ойлеров цикъл - цикъл, в който се обхождат всички ребра точно веднъж.
 
  в G имате Ойлеров път <=> 1. G е свързан. 2. в G има точно два върха от нечетна степен.
  G имате Ойлеров цикъл <=> 1. G е свързан. 2. в G всички върхове са от четна степен. 
 