12. Процедурно програмиране – указатели, масиви и рекурсия. (консултация Димитриев)
 
1. Указатели и указателна аритметика.
 1. def: Указател - променлива, която съдържа адреса на друга променлива.
    <тип>* <име> [ = <стойност> ]     
 
    2 оператора: 
     1. Оператор & за взимане на адрес.
        &<променлива> връща адреса и!!!
      int x = 10;
      int* ptr = &x;  
 
    2. Оператор за дерефериране * 
     *<указател> - връща стойността на променливата, към която сочим!!
 
   Указателите имат неутрална стойност - nullptr. Указателят не сочи на никъде!  
 
 
 
Указателна аритметика: 
        ptr - указател към променлива от тип T.
 
         ptr++ / ptr-- Адресите НЕ се отместват с 1, а се отместват с sizeof(T)!!
         ++ptr / --ptr
 
        ptr + k   ptr се отмества с k * sizeof(T) байта!
 
 
2. Едномерни и многомерни масиви
   Едномерни:   <тип> <име>[<размер>];    int arr[10]; 
 
   1. Елементите на масива са последователно разположени в паметта!!! 
   2. Всички елементи на масива са от един и същи тип.
 
   int arr[10]; 
   std::cout << arr;    // Ще се отпечата адреса на първия елемент на масива
 
Когато напишем arr, то ни връща указател към първия елемент на масива!
 
Така написаните масиви изискват големината да е ясна compile time!!!!!
int arr[3] - Не знаем какви са елементите 
int arr[3] = {1,2,3}
int arr[3] = {1,2,3,4} NO!
int arr[3] = {1};   [1][0][0] //!!!
 
 
Многомерни масиви: 
  Масиви от масиви!
  <тип> <име>[N] [K]  - Масив с N масива, всеки от който е с K елемента. 
 
 
Индексиране - достъп до конкретен елемент в масив.
 
  arr[k] - взимате елемента на индекс k.
	  Индексацията започва от 0!!
  Имате константна индексация!! Намирането на k-ия елемент става чрез една проста аритметична операция !
      - Защото елементите са с равна големина и последователни в паметта! 
arr[i]   <=>    *(arr + i)
 
 
 
Сортиране и търсене в едномерен масив – основни алгоритми
 
   Bubble - нищо
  selection - мин swap
  insertion sort  - добър при масив, който е малко разместен  n^2  
   linear    - n 
  binary search  log(n)  сортирана колекция  
 
 
 
  Рекурсия – функция, която извиква себе си пряко или косвено.
 
 Симеслената рекурсия има две неща:
 1. Рекурсивно извикване
 2. Дъно (базов случай, който се изчислява без рекурсия)
 
Пряка рекурсия: Функция директно извиква себе си
  int f(int x) 
   … f(x - 1)
 
Косвена рекурсия:
 
   int f(int x)    g()                            k()
      ...g()          ..k()                         ...f();
 
Индиректно(чрез други функции) извикване на себе си/
 
 Рекурсия vs итерация 
 Рекурсия = итерация + стек 
 
Рекурсията ползва стек => харчите памет и губите време за добавянето на елементите в стека!
Същестува опашкова рекурсия / tail recursion: Рекурсия, която симулира итеративен процес БЕЗ СТЕК!! 
Опашкова рекурсия - Последното действие на функцията ви е рекурсивното извикване!
 
Линейна рекурсия - едно рекурсивно извикване - пример: факториел
Разклонена рекурсия - повече от едно рекурсивно извикване за изчислението - пример: Фибоначи 